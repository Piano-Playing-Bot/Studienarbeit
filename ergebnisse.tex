

\chapter{Ergebnisse} \label{ergebnisse}
\chapterauthor{Jakob Kautz, Olivier Stenzel, Val Richter}

Nachdem sowohl Hardware als auch Software konzipiert und zu großen Teilen umgestzt wurden, soll nun der entstandene Prototyp abgeschlossen werden.
Dafür wird zunächst ein Kurzüberblick über den gesamten Prototypen gegeben.
In Abschnitt \ref{ergebnisse-tests} werden dann mehrere Tests und Messungen am Prototypen ausgeführt.
Die Ergebnisse der Tests zeigen einerseits die Fähigkeiten und Limitationen des Prototypen auf, können zu Teilen aber auch verwendet werden, um bestehende Probleme der Umsetzung zu lösen.
Zuletzt wird in Abschnitt \ref{ergebnisse-limitationen} noch ein Überblick darüber gegeben, was beim Prototypen noch fehlt, um ihn zu einem vollständigen Produkt zu bringen. % @Note(Val): Der Satz klingt komisch, bitte überarbeiten
Hier werden nicht nur Limitationen der Umsetzung, sondern auch der Konzeption betrachtet, welche in Fortführungen oder Replikationen dieser Arbeit beachtet werden sollten.

% @TODO(Val): Die Beschreibung des Prototypen fühlt sich gerade noch sehr unzureichend an. Weiß aber auch nicht was man da alles schreiben kann, ohne sich zu sehr zu wiederholen.

% @Note(Val): Ist dieser Abschnitt überhaupt relevant?
Obwohl Software und Hardware getrennt von einander entwickelt wurden, war es aufgrund einer klar definierter Schnittstelle einfach, die beiden zusammen zu führen.
Nichtsdestotrotz gab es bei der Zusammenführung einige Probleme, die in einem letzten Schritt der Implementierung ausgemerzt wurden.
Speziell hat sich das Testen der Software des \ac{MC}s ohne verfügbare Hardware als schwierig erwiesen.
Diese Tests mussten entsprechend in diesem letzten Schritt durchgeführt werden und alle dabei auftretenden Fehler mussten gefunden und beseitigt werden.
Der in Kapitel \ref{umsetzungSW-Kommunikation-MC} vorgestellte Ansatz und Pseudocode war dabei richtig, jedoch gab es mehrere kleinere Bugs in den Details.
Der in Anhang \ref{???} beigefügte Quellcode hat beim Testen mit der prototyp-haften Hardware keine Probleme mehr aufgezeigt.

Der Prototyp besteht aus der Hardware, die von einer Desktop-Anwendung aus gesteuert werden kann, um Klaviertasten des Pianos anzuspielen.
Aufgrund zeitlicher Limitationen war es nicht möglich, das gesamte Piano bespielbar zu gestalten.
Nichtsdestotrotz ist der Prototyp mit diesem Ziel entwickelt worden und ist somit leicht erweiterbar, um das gesamte Klavier anzusteuern.
Die Anwendung \ac{SAM} leidet ebenso an Defekten, vor allem im Bereich des \ac{UI} Designs und der Usability.
Allerdings ist die Anwendung funktional und kann Musikstücke aus einem Katalog - der von Nutzer:innen mit \ac{MIDI}-Dateien erweitert werden kann - zum \ac{MC} schicken und abspielen lassen.




\section{Tests \& Messungen} \label{ergebnisse-tests}
\chapterauthor{Olivier Stenzel, Val Richter, Jakob Kautz}

Mit der Fertigstellung des Prototypen, soll dieser nun getestet werden.
Dabei sind die Messungen in zwei Teile geteilt.
Zuerst werden Messungen der Hardware beschrieben (siehe Abschnitt \ref{tests-hw}).
Deren Ergebnisse haben teilweise Auswirkungen auf die Software, um eine korrekte Funktionalität zu versichern.
Daraufhin werden Messungen der Software in Abschnitt \ref{tests-sw} dargestellt.

Es wurden auch Tests durchgeführt, um die Korrektheit des Prototypen zu versichern.
Diese Tests liefen größtenteils jedoch informell durch einfaches Benutzen der Komponenten bzw. des gesamten Prototypen ab und sollen hier nicht genauer geschildert werden.
Es sollte jedoch angemerkt werden, dass der Prototyp alle Tests auf Korrektheit bestanden hat.

\subsection{Hardware-Tests} \label{tests-hw}
\chapterauthor{Olivier Stenzel, Val Richter, Jakob Kautz}

Tabelle \ref{table:hw-tests} listet die unterschiedlichen Messungen auf, die an der Hardware durchgeführt wurden.
In den folgenden Abschnitten wird der Ablauf, die Bedeutung und das Ergebnis jeder Messung ausführlich beleuchtet.
Anpassungen der Software, die aufgrund von Testergebnissen durchgeführt wurden, werden bei den jeweiligen Tests ebenfalls spezifiziert.


% @Note(Val): Add Softwre-Tests
\begin{table}[htbp]
	\centering
	\begin{tabular}{|l|l|}
		\theadstart{ID} & \theadcol{Name} \\ \hline
		HW-T1 & Min. Periodendauer eines Tastendrucks \\ \hline
		HW-T2 & Min. Lautstärke \\ \hline
		HW-T3 & Min. Genauigkeit \\ \hline
	\end{tabular}
	\caption{Hardware-Tests}
	\label{table:hw-tests}
\end{table}

\subsubsection{HW-T1: Min. Periodendauer eines Tastendrucks}

\paragraph{Erklärung:}
Mit der Periode eines Tastendrucks ist hier jene Zeit gemeint, die zwischen doppelten Betätigen derselben Taste vergeht.
Da der Hubmagnet, bevor er einen erneuten Tastendruck initiieren kann, wieder in seinen Ausgangszustand zurückkehren muss, kann diese Periode nicht unendlich reduziert werden, da es sonst nur zu einem konstanten Spielen der Taste kommt.
Es soll sichergestellt werden, dass alle Töne des Stücks erklingen, weshalb das Erfassen der minimalen Periodendauer bedeutsam ist.
Software-seitig kann diese Periodendauer genutzt werden, um zu verhindern, dass ein solches \ac{Verschmelzen} von zwei Anschlägen zu einem konstanten Anspielen vorkommt.

\paragraph{Ablauf:}
Schrittweise wird software-seitig die Frequenz des Anspielens einer Taste erhöht.
Es werden mehrere Tasten für diesen Test verwendet, wobei der Fokus, auf Grund des höchsten Mechanik-Gewichts, auf der tiefsten Taste - der A0 Taste - liegt. % @Note(Val): Was wird mit "Mechanik-Gewicht" gemeint? Vorher wird nie erwähnt, dass manche Tasten ein höheres Gewicht haben. Das wäre vielleicht wichtig vorher schon zu erwähnen
Während des Spielens wird eine Slow-Motion-Aufnahme des Hammers und der Klaviersaite angefertigt ud im Anschluss analysiert.
Wird die Saite angeschlagen, kann die Frequenz im nächsten Schritt erhöht werden.
Sollte sie nicht angeschlagen werden, ist die maximal verwendbare Frequenz (und damit auch die minimale Periodendauer) gefunden und kann in den Code aufgenommen werden.

\paragraph{Ergebnis:}
Die minimale Periodendauer liegt durchschnittlich bei den Tasten bei ca. 30ms.
Das höchste Minimum wurde wie erwartet bei der A0 Taste mit ca. 40ms gefunden. \newline
Software-seitig gibt es nun mehrere Möglichkeiten, dieses Minimum zu forcieren.
Zum Beispiel könnte im \ac{PIDI}-Format vorgegeben werden, dass zwischen zwei Anschlägen eines einzigen Tons immer min. 40ms liegen müssen.
Da das \ac{PIDI}-Format aber unabhängig der Hardware sein soll und diese Begrenzung speziell durch die verwendeten Komponenten aufkommt, ist dies eine eher unschöne Lösung.

Stattdessen wäre es besser wenn nur der \ac{MC} diese Limitierung beachten muss, da nur dieser Wissen über die spezifische Hardware-Umstzung verwenden soll.
Der \ac{MC} muss entsprechend Tasten finden, die so lange gespielt werden sollen, dass ihr nächstes Anspielen weniger als 40ms später erfolgt.
Wenn diese Tasten gefunden wurde, könnte entweder das nächste Anspielen der Taste später erfolgen oder die Spiellänge der Taste reduziert werden.
Da das Anspielen einer Taste sehr viel klarer zu erkennen ist als das Weiterspielen einer Taste, beeinflusst die zweite Strategie den Klang des Musikstücks geringer.

Da der \ac{MC} allerdings immer nur Teile des Musikstücks erhält, kann nicht einfach zu Spielbeginn das gesamte Stück angepasst werden, um die Periodendauer von min. 40ms einzuhalten.
Stattdessen müssen die \lstinline|PlayedKey|s, die der \ac{MC} sich speichert, dynamisch während Spielen des Musikstücks angepasst werden.
Dafür wird durch die nächsten \lstinline|PidiCmd|s iteriert, die in den nächsten 40ms gespielt werden sollen. Falls eine dieser Tasten bereits gespielt wird, muss die Taste jetzt schon aufhören zu spielen.

Dieser Ansatz ist sowohl leicht zu implementieren, als auch performat in der Ausführung.
Allerdings kommt diese Strategie auch mit Nachteilen.
Soll eine Taste beispielsweise für 30ms gespielt werden und dann 5ms später wieder angespielt werden, so wird das erste Anspielen übersprungen.
Ein alternativer Ansatz würde in diesen Fällen das Verschmelzen der Töne in Kauf nehmen.
Das würde jedoch eine etwas kompliziertere Lösung mit sich bringen und es da diese Fälle in der Praxis eher unwahrscheinlich sind, wurde Einfachheit hier vorgezogen.

Eine größere Limitation dieser Lösung liegt dagegen darin, dass zurzeit nur die nächste \lstinline|PidiCmd|s im derzeit zu spielenden Buffer betrachtet werden.
Der zweite Buffer von \lstinline|PidiCmd|s, der beim Lesen neuer \enquote{Music}-Nachrichten befüllt wird, wird bei dieser Prüfung zurzeit ignoriert.
Das bedeutet, dass die derzeitige Umsetzung des Ansatzes nicht vollständig korrekt ist, da das nächste Anschlagen eines Tons im nächsten Buffer liegen könnte.
Allerdings wurde hier wieder die Einfachheit der Implementierung als wichtiger gesehen, da diese Fälle in den praktischen, getesteten Musikstücken nicht oder nur sehr selten aufgetreten sind.


\subsubsection{HW-T2: Min. Lautstärke}

\paragraph{Erklärung:}
Um den leisesten spielbaren Ton zu ermitteln, muss die minimale Spannung ermittelt werden, mit der eine Taste betätigt werden kann.
Wie in Kapitel \enquote{\nameref{subsec:aktuator}} erklärt, benötigt ein Hubmagnet eine entsprechende Minimalspannung, um den Anker zu bewegen.
Da diese Spannung im Datenblatt des Hubmagneten nicht ersichtlich ist und das Tastengewicht sowieso mit einbezogen werden muss, muss diese Mindestspannung beim Klavier experimentell ermittelt werden.

\paragraph{Ablauf:}
Software-seitig wird der Wert, der die Intensität des Anschlags beschreibt, schrittweise soweit reduziert, bis die Taste keinen Ton mehr spielt.
Dies wird an allen (mit Fokus auf den tieferen) Tasten durchgeführt, da sich die einzelnen Tasten in ihrem Ansprechverhalten teils deutlich unterscheiden. % @Note(Val): Erneut - warum wird erst jetzt erwähnt, dass sich die Tasten so stark unterscheiden? Wäre das bei der Konzeption oder dem Anbringen der Aktuatoren an das Piano nicht interessant zu wissen?
Anschließend wird wieder das Größte der einzelnen Minima in den Code mit aufgenommen.

\paragraph{Ergebnis:}
Das leisteste Anspielen der Tasten ist mit einer Spannung von 17,3V möglich.
Als \ac{PWM}-Wert ist dies eine 210 von 256 möglichen Werten.
Der \ac{MC} hat beim Bespielen von Noten eine Anspielstärke als 4-Bit Zahl gegeben (siehe Listing \ref{code:PidiCmd struct}).
Um die Anschlagestärke auf die richtige Skalierung zu bringen kann eine lineare Interpolation verwendet werden.
Listing \ref{code:scaled volume} zeigt, wie das in Code aussehen könnte.
Dabei werden im Listing auch der Lautstärke-Faktor beachtet und Anschlagsstärken von 0 korrekt auf 0 gesetzt.

\begin{UnbrokenCodePage}[style=CStyle, caption={Skalierung der Lautstärke bei der Ausgabe}, label={code:scaled volume}]
#define DELTA 0.00001f
#define MAX_VELOCITY 16
#define MIN_PWM 210
#define MAX_PWM 255
unsigned char velocity; // is assumed to be given as a number between 0 and 15
float volume_factor;    // is assumed to be given as some positive number
float t = volume_factor * velocity / (float)MAX_VELOCITY;
if (t <= DELTA) {
	set(0); // Sets the specified key to recive a PWM value of 0
} else {
	if (t > 1.0f) t = 1.0f;
	set(MIN_PWM + t*(MAX_PWM - MIN_PWM));
}
\end{UnbrokenCodePage}


\subsubsection{HW-T3: Min. Genauigkeit:}

\paragraph{Erklärung:}
Der Zweck dieses Tests besteht darin sicherzustellen, dass der Tastenanschlag des selbstspielenden Klaviers zum richtigen
Zeitpunkt und in der korrekten Reihenfolge erfolgt. Dies gewährleistet die Genauigkeit und Zuverlässigkeit des Klaviers
bei der Wiedergabe von Musikstücken.

\paragraph{Ablauf:}
\begin{enumerate}
	\item Es wird eine einfache Folge von Signalen erstellt, die repräsentativ für eine musikalische Passage ist.
	\item Das selbstspielende Klavier wird mit den erstellten Signalen versorgt, und die Wiedergabe wird mittels einer Videoaufnahme dokumentiert.
	\item Der Test wird mehrmals durchgeführt, um die Konsistenz der Ergebnisse sicherzustellen.
	\item Während der Videoaufnahme wird eine Uhr verwendet, um den Zeitpunkt jedes gespielten Tons zu markieren.
	\item Nach Abschluss des Tests wird das aufgezeichnete Video analysiert, um festzustellen, ob jeder Ton zur erwarteten Zeit gespielt wurde.
	\item Es werden Abweichungen zwischen den erwarteten und tatsächlichen Spielzeiten dokumentiert und bewertet.
\end{enumerate}

\paragraph{Ergebnis:}
Da der Test aufgrund fehlender Zeit nicht durchgeführt werden konnte, werden hier lediglich die Erfolgskriterien aufgezählt:
\begin{enumerate}
	\item Jeder Ton wird zum erwarteten Zeitpunkt gespielt, innerhalb einer akzeptablen Toleranzschwelle von ???ms % @TODO(Val): Was ist die Toleranzschwelle und benennen wir die irgendwo bevor mal?
	\item Die Reihenfolge der gespielten Töne entspricht exakt der vorgegebenen Signalabfolge.
	\item Die Abweichungen zwischen den erwarteten und tatsächlichen Spielzeiten liegen innerhalb akzeptabler Grenzwerte % @TODO(Jay): def this
\end{enumerate}

\subsection{Software-Tests} \label{tests-sw}
\chapterauthor{Val Richter}

Tabelle \ref{table:sw-tests} listet die unterschiedlichen Messungen, die an der Software durchgeführt wurden.
Die Bedeutung dieser Messergebnisse wird im Folgenden beleuchtet.

% @TODO(Val): Collect these test values lol
% @TODO(Val): Füge "Länge für Import von MIDI-Dateien" oder so hinzu
\begin{table}[htbp]
	\centering
	\begin{tabular}{|l|p{10cm}|l|}
		\theadstart{ID} & \theadcol{Beschreibung} & \theadcol{Ergebnis} \\ \hline
		SW-T1 & Durchschnittliche Latenz bei der Kommunikation zwischen \ac{SAM} \& \ac{MC} & ... \\ \hline
		SW-T2 & Minimale Laufzeit einer Iteration des \ac{MC}s während dem Abspielen eines Musikstücks & ... \\ \hline
		SW-T3 & Maximale Laufzeit einer Iteration des \ac{MC}s während dem Abspielen eines Musikstücks & ... \\ \hline
		SW-T4 & Minimale Laufzeit einer Iteration des Kommunikations-Threads in \ac{SAM} während Abspielen eines Musikstücks & ... \\ \hline
		SW-T5 & Maximale Laufzeit einer Iteration des Kommunikations-Threads in \ac{SAM} während Abspielen eines Musikstücks & ... \\ \hline
		SW-T6 & Minimale \ac{FPS} von \ac{SAM} während ausfühlicher Nutzung & ... \\ \hline
		SW-T7 & Maximale \ac{FPS} von \ac{SAM} während ausfühlicher Nutzung & ... \\ \hline
		SW-T8 & Maximaler Speicherverbrauch von \ac{SAM} bei ausführlicher Nutzung von 30 Minuten & ... \\ \hline
	\end{tabular}
	\caption{Software-Tests}
	\label{table:sw-tests}
\end{table}

% @TODO(Val): Beschreiben was diese Ergebnisse bedeuten v.a. mit Hinblick auf Bottlenecks


\section{Limitationen \& Erweiterungsmöglichkeiten} \label{ergebnisse-limitationen}
\chapterauthor{Val Richter, Jakob Kautz}

Aufgrund limitierter Zeit konnte der hier erstellte Prototyp nicht vollständig umgesetzt werden.
Aus den selben Gründen wurden auch bei den gestellen Anforderungen und der Konzeption des Projekts mehrere potenzielle Features ausgelassen.
Auch während der Implementierung sind mehrere Probleme und Unzulänglichkeiten aufgetreten, die wegen der zeitlichen Begrenzung nicht mehr verbessert werden konnten.
Zum Teil wurden diese Limitationen der Konzeption und prototypischen Umsetzung bereits erwähnt.
Der Vollständigkeit halber sollen die größten Limitationen dieser Arbeit hier nochmal gelistet und kurz beschrieben werden.

Im Laufe der Konzeption traten mehrere Herausforderungen auf, welche aus Zeit- und Konsten-Gründen nicht weiter behandelt wurden.

\paragraph{Anzahl Aktuatoren:}
Während insgesamt 88 Aktuatoren für alle Klaviertasten bestellt wurden, hat die Zeit nur gereicht, um insgesamt 8 Hubmagnete mit der Schaltung zu verbinden.
Für Testzwecke wurden allerdings bereits 40 von 88 LEDs mit der Schaltung verbunden.
Das Hinzufügen der letzten 80 Aktuatoren ist trivial aber natürlich recht zeitaufwendig.

\paragraph{Maximum gleichzeitig spielender Tasten}
Die in dieser Arbeit verwendeten Hubmagnete benötigen jeweils etwa 0.7 Ampere.
Das im Prototypen genutzte Netzteil ist auf 6 Ampere ausgelegt.
Damit wäre es in diesem Aufbau möglich bis zu 8 Aktuatoren gleichzeitig anzusteuern.
Da der Hauptanwendungsfall beim Spielen von Musik besteht, die für einzelne Pianos komponiert wurde, welche seltens mehr als 8 Tasten gleichzeitig bespielen müssen, sollte diese Limitation nicht oft in der Praxis relevant werden.
Nichtsdestotrotz musste diese Limitation in der Software des \ac{MC}s umgesetzt werden (siehe Abschnitt \ref{vorgehenSW-MC}), um nicht zu viel Strom vom Netzteil zu ziehen.

\paragraph{Pedalansteuerung}
Ein Klavier hat im Regelfall zwei bis drei Pedale, welche die Dynamik und den Klang des Klaviers beeinflussen.
Trotz des klangtechnischen Mehrwehrts, den Pedale bringen, wurden sie hier ignoriert.
Um Pedale zusätzlich anzusprechen müssten einige Teile des Konzepts erweitert werden.
So bräuchte es mindestens zwei weitere \ac{PWM}-Ausgänge, die über ein zusätzliches Schieberegister oder weiter \ac{PWM}-Ports des Arduinos zu verbinden wären.
Weiterhin müssten leistungsfähigere Aktuatoren als die hier verwendeten Hubmagnete zum Anspielen der Pedale benutzt werden, da die Pedale schwerer als die Tasten des Klaviers sind.
Eine Methodik zum Anspielen der Pedale müssten ebenfalls noch überlegt werden.
Zuletzt müsste auch die Software dafür erweitert werden.
Hier müsste entweder ein Algorithmus entwickelt werden, um anhand des \ac{PIDI}-Formats zu erkennen, wann das Pedal wie stark gedrückt werden soll, oder das \ac{PIDI}-Format müsste um Pedal-Informationen erweitert werden.

\paragraph{Wärmeabfuhr}
Da die Hitzeentwicklung der Hubmagnete mit der Dauer der Nutzung stark ansteigt, ist die Holzplatte bezogen auf die Wärmeabfuhr nicht geeignet.
Besser würde sich hier eine Metallplatte anbieten, auf der die Aktuatoren verschraubt werden.
Aus Kostengründen wurde das beim Prototypen hier noch nicht umgesetzt.

\paragraph{Sicherheitskonzept}
Es besteht bei der Konzeption deer Hardware kein Sicherheitskonzept. Die Wärmeabfuhr wurde für den Bereich Temperaturkontrolle
bereits genannt. Dazu kommt, dass auch Bauteile wie die MOSFETS bei dauerhafter Nutzung erhitzen werden. Es wäre eine Möglichkeit,
die Bauteile mit Kühlkörpern zu versehen um den Temperaturanstieg zu vermeiden.\newline
Es besteht außerdem keine Konzeption von Gehäusen um die Hardware zu schützen. Somit kann diese beschädigt werden. Außerdem
sind auch die Stromverbindungen zu dem externen Stromanschluss von 24V frei zugänglich. Hier sollten Gehäuse entworfen werden,
die die Schaltung schützen und es sollte ein Konzept zur Isolation entworfen werden.\newline
Auch der Stromschutz ist nicht gegeben, da technisch gesehen jedes Netzteil, egal mit welcher Stromstärke, angeschlossen
werden könnte und es keine Mechanismen gibt um den Überstrom zu behandeln. Hier sollten Sicherungen oder Leistungsschalter
eingebaut werden, um die Brandgefahr zu verringern.

\paragraph{Eingabedateien}
Die Desktop-Anwendung \ac{SAM} unterstüzt nur den Import von \ac{MIDI}-Dateien.
Die Untertützung weiterer Formate wäre hier wünschenswert.
Speziell das Hinzufügen von Dateien, die grundlegend andere Informationen speichern, wie beispielsweise Bild-Dateien von Notensheets oder generelle Audio-Dateien, wären hier von besonderem Interesse.
Die Forschungsfelder \enquote{Optical Music Recognition} und \enquote{Musical Note Recognition} bieten hier respektiv Einblicke, wie Noten-Informationen aus solchen Formaten gewonnen werden könnten.

\paragraph{Vollständige \ac{MIDI} Unterstützung}
Sogar das \ac{MIDI}-Format selbst wurde für den Prototypen nicht vollständig unterstützt.
Bestimmte \ac{MIDI}-Dateien, die eine alternative Enkodierung der Zeit verwenden, können beispielsweise nicht korrekt geparst werden.
Auch bei einigen anderen Dateien, wurde ein fehlerhaftes Parsing festgestellt.
Aufgrund zeitlicher Begrenzungen, konnte nicht untersucht werden, woher diese Fehler kommen.

\paragraph{\ac{UI} Design}
Das Design der \ac{UI} ist nicht besonders ansprechend.
Während in der Konzeption mehrere Darstellungsmöglichkeiten des Musik-Katalogs bedacht wurden, wurde in der Implementierung nur eine sehr unschöne Version umgesetzt (siehe Abbildung \ref{???}). % @TODO(Val): Referenz auf Screenshot der UI, wahrscheinlich bei umsetzungSW-UI

\paragraph{Musikverwaltung}
\ac{SAM} erlaubt zwar das Hinzufügen von Musikstücken mit selbstgewähltem Namen, das spätere Umbenennen oder Löschen der Musikstücke fehlt allerdings.
Auch bietet das System der Musikverwaltung zurzeit nur einen einzelnen Katalog an.
Es wäre denkbar und womöglich sinnvoll, der Nutzer:in die Erstellung und Verwaltung von Alben zu erlauben, ähnlich wie es bei bekannten Musikplayern (z.B. \ac{WMP} und Spotify) auch möglich ist.
Mit der Existenz von Alben würde auch das Abspielen eines gesamten Albums und der Kontrolle über zufällige und wiederholte Wiedergabe des Albums ein attraktives Feature sein.

\paragraph{Fehlende Fehlermeldungen}
\ac{SAM} hat kein System, um Fehlermeldungen anzuzeigen.
Stattdessen wird bei unerwarteten Zuständen die Anwendung gewaltsam abgestürzt.

\paragraph{Datenkonsistenz von \ac{SPPP}-Nachrichten}
Das \ac{SPPP}-Protokoll hat keine eingebauten Mechanismen zum Sicherstellen der Datenkonsistenz.
Es muss entsprechend darauf vertraut werden, dass das Übertragungsmedium die Nachrichten vollständig und korrekt überträgt.
Die Nutung von Parity Bits oder Ähnlichem würde die Datenkonsistenz stärker versichern.

% @TODO(Val): Bei Limitationen müssen auf jeden Fall Sicherheitsrisiken, etc. der Hardware noch erwähnt werden