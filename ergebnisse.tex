

\chapter{Ergebnisse} \label{ergebnisse}
\chapterauthor{Jakob Kautz, Olivier Stenzel, Val Richter}
\nocite{*}

Nachdem sowohl Hardware als auch Software konzipiert und zu großen Teilen umgestzt wurden, soll nun der entstandene Prototyp abgeschlossen werden.
Dafür wird zunächst ein Kurzüberblick über den gesamten Prototypen gegeben.
In Abschnitt \ref{ergebnisse-tests} werden dann mehrere Tests und Messungen am Prototypen ausgeführt.
Die Ergebnisse der Tests zeigen einerseits die Fähigkeiten und Limitationen des Prototypen auf, können zu Teilen aber auch verwendet werden, um bestehende Probleme der Umsetzung zu lösen.
Zuletzt wird in Abschnitt \ref{ergebnisse-limitationen} noch ein Überblick darüber gegeben, was beim Prototypen noch fehlt, um ihn zu einem vollständigen Produkt zu bringen. % @Note(Val): Der Satz klingt komisch, bitte überarbeiten
Hier werden nicht nur Limitationen der Umsetzung, sondern auch der Konzeption betrachtet, welche in Fortführungen oder Replikationen dieser Arbeit beachtet werden sollten.

% @TODO(Val): Die Beschreibung des Prototypen fühlt sich gerade noch sehr unzureichend an. Weiß aber auch nicht was man da alles schreiben kann, ohne sich zu sehr zu wiederholen.

% @Note(Val): Ist dieser Abschnitt überhaupt relevant?
Obwohl Software und Hardware getrennt von einander entwickelt wurden, war es aufgrund einer klar definierter Schnittstelle einfach, die beiden zusammen zu führen.
Nichtsdestotrotz gab es bei der Zusammenführung einige Probleme, die in einem letzten Schritt der Implementierung ausgemerzt wurden.
Speziell hat sich das Testen der Software des \ac{MC}s ohne verfügbare Hardware als schwierig erwiesen.
Diese Tests mussten entsprechend in diesem letzten Schritt durchgeführt werden und alle dabei auftretenden Fehler mussten gefunden und beseitigt werden.
Der in Kapitel \ref{umsetzungSW-Kommunikation-MC} vorgestellte Ansatz und Pseudocode war dabei richtig, jedoch gab es mehrere kleinere Bugs in den Details.
Der in Anhang \ref{???} beigefügte Quellcode hat beim Testen mit der prototyp-haften Hardware keine Probleme mehr aufgezeigt.

Der Prototyp besteht aus der Hardware, die von einer Desktop-Anwendung aus gesteuert werden kann, um Klaviertasten des Pianos anzuspielen.
Aufgrund zeitlicher Limitationen war es nicht möglich, das gesamte Piano bespielbar zu gestalten.
Nichtsdestotrotz ist der Prototyp mit diesem Ziel entwickelt worden und ist somit leicht erweiterbar, um das gesamte Klavier anzusteuern.
Die Anwendung \ac{SAM} leidet ebenso an Defekten, vor allem im Bereich des \ac{UI} Designs und der Usability.
Allerdings ist die Anwendung funktional und kann Musikstücke aus einem Katalog - der von Nutzer:innen mit \ac{MIDI}-Dateien erweitert werden kann - zum \ac{MC} schicken und abspielen lassen.




\section{Tests \& Messungen} \label{ergebnisse-tests}
\chapterauthor{Olivier Stenzel, Val Richter}

Mit der Fertigstellung des Prototypen, soll dieser nun getestet werden.
Tabelle \ref{table:tests} listet die unterschiedlichen Tests auf, die durchgeführt wurden.
In den folgenden Abschnitten wird der Ablauf, die Bedeutung und das Ergebnis jedes Tests ausführlich beleuchtet.
Abschließend werden in Sektion \ref{tests-messungen} noch mehrere Messergebnisse des Prototypens vorgestellt.

Wie in einigen Tests ersichtlich wird, ist für eine korrekte Funktionalität der Hardware die Einführung einer Software-seitigen Begrenzungen notwendig.
Anpassungen der Software, die aufgrund von Testergebnissen durchgeführt wurden, werden bei den jeweiligen Tests ebenfalls spezifiziert.


% @Note(Val): Add Softwre-Tests
\begin{table}[htbp]
	\centering
	\begin{tabular}{|l|l|}
		\theadstart{ID} & \theadcol{Name} \\ \hline
		T1 & Min. Periodendauer eines Tastendrucks \\ \hline
		T2 & Min. Lautstärke \\ \hline
		T3 & Min. Genauigkeit \\ \hline
	\end{tabular}
	\caption{Tests}
	\label{table:tests}
\end{table}

\subsubsection{T1: Min. Periodendauer eines Tastendrucks}

\paragraph{Erklärung:}
Mit der Periode eines Tastendrucks ist hier jene Zeit gemeint, die zwischen doppelten Betätigen derselben Taste vergeht.
Da der Hubmagnet, bevor er einen erneuten Tastendruck initiieren kann, wieder in seinen Ausgangszustand zurückkehren muss, kann diese Periode nicht unendlich reduziert werden, da es sonst nur zu einem konstanten Spielen der Taste kommt.
Es soll sichergestellt werden, dass alle Töne des Stücks erklingen, weshalb das Erfassen der minimalen Periodendauer bedeutsam ist.
Software-seitig kann diese Periodendauer genutzt werden, um zu verhindern, dass ein solches \ac{Verschmelzen} von zwei Anschlägen zu einem konstanten Anspielen vorkommt.

\paragraph{Ablauf:}
Schrittweise wird software-seitig die Frequenz des Anspielens einer Taste erhöht.
Es werden mehrere Tasten für diesen Test verwendet, wobei der Fokus, auf Grund des höchsten Mechanik-Gewichts, auf der tiefsten Taste - der A0 Taste - liegt. % @Note(Val): Was wird mit "Mechanik-Gewicht" gemeint? Vorher wird nie erwähnt, dass manche Tasten ein höheres Gewicht haben. Das wäre vielleicht wichtig vorher schon zu erwähnen
Während des Spielens wird eine Slow-Motion-Aufnahme des Hammers und der Klaviersaite angefertigt ud im Anschluss analysiert.
Wird die Saite angeschlagen, kann die Frequenz im nächsten Schritt erhöht werden.
Sollte sie nicht angeschlagen werden, ist die maximal verwendbare Frequenz (und damit auch die minimale Periodendauer) gefunden und kann in den Code aufgenommen werden.

\paragraph{Ergebnis:}
Die minimale Periodendauer liegt durchschnittlich bei den Tasten bei ca. 30ms.
Das höchste Minimum wurde wie erwartet bei der A0 Taste mit ca. 40ms gefunden. \newline
Software-seitig gibt es nun mehrere Möglichkeiten, dieses Minimum zu forcieren.
Zum Beispiel könnte im \ac{PIDI}-Format vorgegeben werden, dass zwischen zwei Anschlägen eines einzigen Tons immer min. 40ms liegen müssen.
Da das \ac{PIDI}-Format aber unabhängig der Hardware sein soll und diese Begrenzung speziell durch die verwendeten Komponenten aufkommt, ist dies eine eher unschöne Lösung.

Stattdessen wäre es besser wenn nur der \ac{MC} diese Limitierung beachten muss, da nur dieser Wissen über die spezifische Hardware-Umstzung verwenden soll.
Der \ac{MC} muss entsprechend Tasten finden, die so lange gespielt werden sollen, dass ihr nächstes Anspielen weniger als 40ms später erfolgt.
Wenn diese Tasten gefunden wurde, könnte entweder das nächste Anspielen der Taste später erfolgen oder die Spiellänge der Taste reduziert werden.
Da das Anspielen einer Taste sehr viel klarer zu erkennen ist als das Weiterspielen einer Taste, beeinflusst die zweite Strategie den Klang des Musikstücks geringer.

Da der \ac{MC} allerdings immer nur Teile des Musikstücks erhält, kann nicht einfach zu Spielbeginn das gesamte Stück angepasst werden, um die Periodendauer von min. 40ms einzuhalten.
Stattdessen müssen die \lstinline|PlayedKey|s, die der \ac{MC} sich speichert, dynamisch während Spielen des Musikstücks angepasst werden.
Dafür wird durch die nächsten \lstinline|PidiCmd|s iteriert, die in den nächsten 40ms gespielt werden sollen. Falls eine dieser Tasten bereits gespielt wird, muss die Taste jetzt schon aufhören zu spielen.

Dieser Ansatz ist sowohl leicht zu implementieren, als auch performat in der Ausführung.
Allerdings kommt diese Strategie auch mit Nachteilen.
Soll eine Taste beispielsweise für 30ms gespielt werden und dann 5ms später wieder angespielt werden, so wird das erste Anspielen übersprungen.
Ein alternativer Ansatz würde in diesen Fällen das Verschmelzen der Töne in Kauf nehmen.
Das würde jedoch eine etwas kompliziertere Lösung mit sich bringen und es da diese Fälle in der Praxis eher unwahrscheinlich sind, wurde Einfachheit hier vorgezogen.

Eine größere Limitation dieser Lösung liegt dagegen darin, dass zurzeit nur die nächste \lstinline|PidiCmd|s im derzeit zu spielenden Buffer betrachtet werden.
Der zweite Buffer von \lstinline|PidiCmd|s, der beim Lesen neuer \ac{Music}-Nachrichten befüllt wird, wird zurzeit ignoriert.
Das bedeutet, dass die derzeitige Umsetzung des Ansatzes nicht vollständig korrekt ist, da das nächste Anschlagen eines Tons im nächsten Buffer liegen könnte.
Allerdings wurde hier wieder die Einfachheit der Implementierung als wichtiger gesehen, da diese Fälle in den praktischen, getesteten Musikstücken nicht oder nur sehr selten aufgetreten sind.


\subsubsection{T2: Min. Lautstärke:}

Erklärung: Um den am leisesten spielbaren Ton zu ermitteln, muss die minimale Spannung ermittelt werden, mit der eine Taste betätigt werden kann.
Wie in Kapitel \enquote{\nameref{subsec:aktuator}} erklärt, benötigt ein Hubmagnet eine entsprechende Ansprechspannung, um den Anker zu bewegen.
Da diese Spannung im Datenblatt des Hubmagneten nicht ersichtlich ist und das Tastengewicht sowieso mit einbezogen werden muss, muss diese Mindestspannung beim Klavier experimentell ermittelt werden.

Ablauf: Software-seitig wird der Wert, der die Intensität des Anschlags beschreibt (siehe Kapitel \enquote{\nameref{vorgehenSW-MC}}) schrittweise soweit reduziert, bis die Taste keinen Ton mehr spielt.
Dies wird an allen (mit Fokus auf den tieferen) Tasten durchgeführt, da sich die einzelnen Tasten in ihrem Ansprechverhalten teils deutlich unterscheiden. % @Note(Val): Erneut - warum wird erst jetzt erwähnt, dass sich die Tasten so stark unterscheiden? Wäre das bei der Konzeption oder dem Anbringen der Aktuatoren an das Piano nicht interessant zu wissen?
Anschließend wird der Größte der einzelnen Minima in den Code mit aufgenommen.

Ergebnis: Das leisteste Anspielen der Tasten ist mit einer Spannung von 17,3V möglich.
Dieses Ergebnis fließt in die Lautstärkeregelung der Software ein.
% @TODO(Val): Hier sollte vermutlich die Lösung im Code kurz erklärt werden


\subsubsection{T3: Min. Genauigkeit:}

% @TODO(Val): muss noch geschrieben werden



\subsection{Messergebnisse} \label{tests-messungen}

% @TODO(Val): Füg auch Hardware-Messungen hinzu
Software-Messungen: \newline
- Kommunikationsgeschwindigkeit \newline
- FPS beim Arduino \newline
- FPS bei UI \newline
- FPS bei Comm-Thread der UI \newline
- Speicherverbrauch der UI \newline
- Code-Komplexität (ist das interessant?) \newline
- Lines of Code (i guess?) \newline





\section{Limitationen \& Erweiterungsmöglichkeiten} \label{ergebnisse-limitationen}
\chapterauthor{Jakob Kautz, Olivier Stenzel}

% @TODO(Val): Überarbeiten, jetzt da die Limitationen hier im Ergebnisse Kapitel vorkommen

Im Laufe der Konzeption traten mehrere Herausforderungen auf, welche aus Zeit- und Konsten- Gründen nicht weiter
behandelt wurden.
\paragraph{Anzahl der Aktuatoren}
Wie bereits erklärt, wurden insgesamt 88 Aktuatoren verbaut, womit jede Taste angespielt werden kann. Trotz der Anzahl an
Hubmagneten, werden maximal 10 Tasten glechzeitig angespielt. Dies liegt an der Stromversorgung. Ein Hubmagnet benötigt
eine Stromversorgung von etwa 0.4 Ampere, für 10 Aktuatoren sind das also 4 Ampere. Das Netzteil welches wir verwenden, ist auf
6(?) Ampere ausgelegt, wobei wir mit einem Netzteil getestet haben, welches 2,8 Ampere unterstützt. Es gibt Netzteile die
einen höheren Stromföuss ermöglichen, allerdings sind diese um weiten teurer als das Netzteil, für welches wir uns entschieden haben.
Es wäre auch möglich, ein zweites Netzteil parallel zu Schalten, wodurch die Kosten nicht dramatisch gestiegen wären.
Wir haben hier allerdings keinen Mehrwert mehr gesehen. Die Logik und Ansteuerung des Klaviers bleibt die gleiche, weswegen
wir bei einem Netzteil mit einem maximalen Stromfluss von 6 Ampere (und 24V Leistung) verblieben sind.

\paragraph{Pedalansteuerung}
Ein Klavier hat normalerweise zwei oder drei Pedale, welche die Dynamik und den Klang des Klaviers beeinflussen.
Diese sind schwerer anzuspielen als die Tasten und benötigen somit Leistungsfähigere Aktuatoren als wir für die Tasten nutzen.
Es gab eine Überlegung diese Aktuatoren zu besorgen, da die Pedale klangtechnisch Mehrwert bringen.
Außerdem hätten wir uns noch Gedanken bezüglich der Schaltug und des Signals machen können.
Einerseits hätte ein weiteres Schieberegister genutzt werden können, wobei das Signal angepasst wird das die letzten 6 Ausgänge nie ein Signal bekommen.
ANdererseits hätten die Pedale mit weiteren \ac{PWM} Ports des Arduinos verbunden werden können und die Signale unabhängig von den
Schieberegistern erhalten können.
Im Prinzip wäre die Idee hier allerdings wieder dieselbe wie beim Rest des Projektes gewesen,
weswegen wir Kosten an den Aktuatoren und der extra Stromversorgung für die Pedale gespart haben und diese nicht ansteuern.

\paragraph{Wärmeabfuhr}
Da die Hitzeentwicklung der Hubmagnete mit dem Dauer der Nutzung stark ansteigt, ist die Holzplatte bezogen auf die Wärmeabfuhr nicht geeignet.
Besser würde sich hier eine Metallplatte anbieten, auf der die Aktuatoren verschraubt werden.


% @TODO(Val): Müssen noch ausformuliert werden:
Software Limitationen: \newline
- nur MIDI, kein Image→/Ton→PIDI \newline
- UI Design ist verbesserungsfähig \newline
- SPPP garantiert keine Datenkonsistenz \newline
- SPPP ist nicht auf mehrere Nutzer:innen ausgelegt \newline
- Mögliche Fehler in SPPP (siehe Github issue) \newline
- siehe Github issues \newline
- Es wurde nicht getestet, ob Flash-Speicher (der oftmals ausreichend groß ist) zum Speichern eines gesamten Songs ausgereicht hätte und welche Performanz-Probleme das mit sich gebracht hätte. Dann wäre Streaming unnötig. Wurde aber nicht getestet, ob das überhaupt eine viable Alternative wäre \newline