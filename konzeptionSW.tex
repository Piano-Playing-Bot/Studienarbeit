%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Autoren des Abschnitts:
%   Val Richter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% !TEX root =  master.tex
\nocite{*}
\chapter{Konzeption - Software} \label{vorgehenSW}
\chapterauthor{Val Richter}

Wie in Kapitel \ref{Zielstellung} beschrieben, benötigt dieses Projekt einen Desktop-Anwendung für die Nutzer:innen-Interaktion mit dem selbst-spielenden Klavier.
Außerdem wurde in Kapitel \ref{Hardware - Konzeption} bereits aufgezeigt, dass für die Ansteurung der Motoren ein \ac{MC} verwendet werden soll, der natürlich auch eine bestimmte Software ausführen muss.
Beide Komponenten, das \ac{UI} und der \ac{MC}, sollen in diesem Kapitel konzipiert werden.

Abbildung \ref*{fig:high-level-komponenten} zeigt diese unterschiedlichen Komponenten, sowie den Datenfluss zwischen diesen.
Nutzer:innen werden in der Abbildung auch dargestellt, um eindeutig zu machen, dass Nutzer-Eingaben nur an die \ac{UI} gehen.
Der \ac{MC} erhält Daten zum abzuspielenden Musikstück von der \ac{UI} und schickt darauf basierend in regelmäßigen Intervallen \ac{PWM}-Signale an die Hardware.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[node distance=2cm, line width=0.25mm]
        % Code for drawing a stick figure as taken from https://tex.stackexchange.com/a/441952
        % \begin{tikzpicture}
        % 	\thicklines
        % 	\put(5,18){\circle{5}}
        % 	\put(5,7){\line(0,1){8}}
        % 	\put(5,7){\line(1,-2){5}}
        % 	\put(5,7){\line(-1,-2){5}}
        % 	\put(1,12){\line(1,0){8}}
        % \end{tikzpicture}
        \node (user) [rect] {User}; % @TODO(Val): draw Useer as stick figure
        \node (ui) [rect, below of=user] {UI};
        \node (mc) [rect, right of=ui, xshift=1.5cm] {\ac{MC}};
        \node (hw) [rect, right of=mc, xshift=1.5cm] {Hardware};

        \draw [arrow] (user) -- (ui);
        \draw [arrow] (ui) -- (mc);
        \draw [arrow] (mc) -- (hw);
    \end{tikzpicture}
    \caption{Komponenten-Diagramm mit Datenfluss}
    \label{fig:high-level-komponenten}
\end{figure}

Da die Hardware-Komponente in vorherigen Kapiteln bereits behandelt wurde, soll hier nur die Architektur der \ac{UI} (in Abschnitt \ref{vorgehenSW-UI}) und des \ac{MC} (in Abschnitt \ref{vorgehenSW-MC}) erarbeitet werden.
Dabei soll die Kommunikation zwischen diesen beiden Komponenten in Abschnitt \ref{vorgehenSW-SPPP} ebenfalls seperat betrachtet und spezifiziert werden.
Damit können die beiden Komponenten relativ aufwandsarm verändert oder ausgetauscht werden, solange sie sich weiterhin an das selbe Kommunikations-Protokoll halten.

Weiterhin soll auch das Format, in dem Musikstücke auf dem \ac{MC} gespeichert werden, in Abschnitt \ref{vorgehenSW-PIDI} seperat entworfen werden.
Da der \ac{MC} eine möglichst hohe Geschwindigkeit für die Ansteuerung der Motoren erbringen soll, muss das Format eine performante Nutzung ermöglichen.
Auch muss das Format möglichst wenig Speicherplatz aufbrauchen, damit möglichst viele Daten auf einmal auf dem \ac{MC} gespeichert werden können.
Je mehr Speicherplatz das Format nämlich benötigt, desto öfter muss die \ac{UI} Daten an den \ac{MC} schicken, was einen hohen Zeitaufwand mit sich bringen kann.

Zuletzt soll außerdem auch die Architektur der \ac{UI} in zwei Teile geteilt werden.
Die \ac{UI} hat an sich drei klar separierbare Aufgaben.
Zum einen muss die \ac{UI} natürlich Nutzer:innen-Eingaben verarbeiten und ein graphisches Interface rendern.
Zum anderen muss die \ac{UI} wie bereits erwähnt auch Daten an den \ac{MC} schicken.
Wie in Unterkapitel \ref{vorgehenSW-SPPP} aufgezeigt wird, muss die \ac{UI} auch Daten vom \ac{MC} empfangen können.
Die UI muss zusätzlich zum Rendering und der Kommunikation aber auch noch das Importieren von Musikstücken erlauben.
Wie in \ref{Zielstellung} spezifiziert, sollen Nutzer:innen Musikstücke in bestimmten Dateiformaten an die Anwendung geben können, um diese danach auf dem selbst-spielenden Klavier abspielen zu können.
Konzeptionelle Überlegungen dazu werden in \ref{vorgehenSW-MIDI} erläutert.


\section{Datenformat für Musikstücke} \label{vorgehenSW-PIDI}

Es gibt bereits viele Datenformate, die zum Speichern von Musikstücken verwendet werden können. Dabei lassen sich solche Formate generell in zwei fundamental verschiedenen Designs unterscheiden.

% @Note(Val): Sollten wir Quellen für die unterschiedlichen Formate hier in den Fußzeilen angeben? Z.B. auf die Standards verweisen?
Zum Einen gibt es generelle Audioformate. Dazu gehören solche Formate wie MP3, WAV oder FLAC.
Diese Formate speichern für jeden Zeitpunkt des Audios die Information über das Geräusch, das zu diesem Zeitpunkt abzuspielen ist.

Zum Anderen gibt es Formate, die speziell für Musikstücke entwickelt wurden.
Das Vorzeige-Beispiel wäre hier das \ac{MIDI}-Format.
Bei diesen Formaten werden stattdessen Informationen über Noten, die für eine gewisse Zeit zu spielen sind, gespeichert.
Das genaue Geräusch, das am Ende abgespielt werden sollte, wird dabei noch von anderen Faktoren beeinflusst.
So könnten mehrere Noten gleichzeitig zu spielen sein.
Auch könnte zum Beispiel das Instrument von Nutzer:innen dynamisch änderbar sein.

% @Note(Val): Ich sage öftermal "dieses Projekt". Gefällt uns das stilistisch? Machen wir das einheitlich?
Die zweite Art an Formaten ist im Kontext dieses Projekts zu bevorzugen, da es dem Format der Ausgabe näher kommt.
Die erstgenannten Formate speichern direkt die Informationen, die von digitalen Lautsprechern zum Abspielen von Audio benötigt werden.
Auch wenn je nach Format und Platform womöglich noch einige Datentransformationen getan werden müssen, bevor der Lautsprecher die Daten erhalten kann, ist eine Umwandlung von Informationen nicht notwendig.
% @Note(Val): Sollte hier vielleicht erwähnt werden, warum Informations-Umwandlung zu vermeiden ist?

Zum Anspielen eines Klaviers, werden stattdessen zu jedem Zeitpunkt die Information über derzeit zu spielende Tasten benötigt.
Formate der zweiten Art speichern genau jene Informationen und sind damit perfekt für diese Aufgabe geeignet.
Auf den ersten Blick erscheint die Verwendung eines Formats wie \ac{MIDI} damit eine gute Idee.
Es gibt hier allerdings noch weitere Aspekte, die zu beachten sind.

Dieses Projekt will explizit eine höhere Performanz als die schnellsten menschlichen Pianist:innen erreichen (siehe Kapitel \ref*{Zielstellung}).
Entsprechend sollte das gewählte Datenformat der Musikstücke auch möglichst schnell in das Format umgeformt werden können, das für die Ausgabe an die Aktuatoren benötigt wird.
Am performantesten wäre es hierbei, eine Liste jener Daten zu speichern, die zu jedem Zeitpunkt an die Aktuatoren ausgegeben werden müssen, da dann gar keine Datentransformation mehr nötig ist.

% @Note(Val): Muss ich erklären, warum erhöhte Kommunikation die Performanz beeinträchtigen könnte oder ist das selbsterklärend?
Allerdings muss das Datenformat auch möglichst wenig Speicherplatz verbrauchen.
Da der Code auf einem \ac{MC} laufen muss, ist Speicherplatz relativ begrenzt.
Der \ac{MC} muss dabei nicht das gesamte Musikstück auf einmal gespeichert haben, da restliche Teile des Musikstücks auch später von der \ac{UI} nachgereicht werden können.
Das verringert die Wichtigkeit des Speicherplatzes jedoch nur zu Teilen, da ein solches Streamen der Daten mehr Kommunikation zwischen \ac{UI} und {MC} benötigt.
Da die Latenzen der Kommunikation relativ hoch sein können, gefährdet dies wiederrum das Ziel der Performanz.
% @TODO(Eine Anmerkung wie hoch Latenz & Throughput sein können (oder wo diese Zahlen genannt werden), wäre hier gut)

% @TODO(Val): Quellen für \ac{MIDI} Details einfügen
\ac{MIDI} schneidet hierbei an sich sehr gut ab, da Noten sehr kompakt abgespeichert werden.
Dafür wird eine Enkodierung variabler Länge verwendet.
Da \ac{MIDI} allerdings ein generelles Format ist, das ein Vielzahl von digitalen Instrumenten und Synthesizers unterstützen möchte, beinhält der \ac{MIDI}-Standard eine Vielzahl optionaler Metadaten, die für dieses Projekt irrelevant sind.
Entsprechend würde nur ein Subset des \ac{MIDI}-Standards zum Speichern der Musikdaten in Frage kommen.
Nichtsdestotrotz kann das Format für diesen eingeschränkten Anwendungsfall noch optimiert werden.
Um diese Verbesserungen zu motivieren, soll zuerst die Enodierung von Noten in \ac{MIDI} erläutert werden.

\ac{MIDI} speichert die Notenfolgen in sogenannten \enquote{Nachrichten}.
Nachrichten können auch andere Daten tragen, hier sollen aber nur die Nachrichten zum Spielen von Tönen betrachtet werden.
Jede dieser Nachrichten folgt einer relativen Zeitangabe, im Standard \enquote{delta time} genannt.
\enquote{delta time} gibt an, wie viele Schläge der virtuellen \ac{MIDI}-Uhr zwischen der letzten Nachricht und dieser vergehen sollen.
Die \ac{MIDI}-Uhr kann direkt in Angaben einer Wand-Uhr umgerechnet werden.
Hier ist jedoch wichtig zu bemerken, dass diese \ac{MIDI}-Uhr sehr viel genauer als eine Angabe in Millisekunden ist.
Auch ist zu erwähnen, dass diese \enquote{delta time} eine variable Länge hat, mindestens aber immer ein Byte verwendet.

Nach der \enquote{delta time} folgt dann genau ein Byte für den \enquote{Ereignis-Code} der Nachricht.
Dieser gibt in jeweils 4 Bits den \enquote{Status} und den \enquote{Kanal} des Ereignisses an.
Während der Status angibt, was für eine Aktion ausgeführt werden soll und damit auch wie viele Datenbytes für diese Nachricht noch folgen, besagt der Kanal, für welches Instrument dieses Ereignis gilt.
Wenn die Note gespielt werden soll, folgen darauf noch zwei Bytes, die jeweils die Note und die Anspielstärke abspeichern.
Wenn mit dem Spielen der Note aufgehört werden soll, folgt nur ein Byte, das die jeweilige Note angibt.

Hierbei fallen einige Daten auf, die in diesem Projekt unnötig sind.
So gibt es hier zum Beispiel nur ein einziges Instrument, weswegen die Notwendigkeit unterschiedlicher Kanäle wegfällt.
Auch ist die sehr hohe Auflösung der \enquote{delta time} hier nicht benötigt.
Stattdessen würde eine Auflösung in Millisekunden oder Centisekunden für dieses Projekt ausreichen.

Weiterhin fällt auf, dass für das Spielen jedes Tons in \ac{MIDI} mindestens zwei Nachrichten benötigt werden.
Einmal eine Nachricht zum Starten des Ton-Spielens und einmal eine Nachricht zum Aufhören.
Diese zweite Nachricht wäre nicht nötig, wenn zusammen mit der ersten Nachricht eine Länge, mit der der Ton gespielt werden soll, gespeichert würde.
Diese Speicher-Optimierung bringt allerdings auch Nachteile mit sich.
So verkompliziert es die Transformation der Musikdaten, bevor sie zum Ansteuern der Aktuatoren verwendet werden können.
Auch müssen die zeitlichen Längen, für die die zurzeit spielenden Töne noch zu spielen sind, gespeichert werden.
Dies könnte im Generellen einiges an Speicherplatz verbrauchen.
In diesem speziellen Anwendungsfall lässt sich allerdings annehmen, dass Noten in der Regel nur für relativ kurze Zeiten gespielt werden und dass nur relativ wenige Noten auf einmal gespielt werden.
Da wie in Kapitel \ref{???} erklärt, auch nur eine geringe Anzahl der Aktuatoren auf einmal aktiviert werden sollen, kann die Menge zusätzlich benötigten Speichers hier sehr gering gehalten werden.

Aufgrund all dieser möglichen Verbesserungen des Formats, wurde sich entschieden, ein eigenes Datenformat für diesen Anwendungsfall zu entwickeln, welches im Folgenden \enquote{\ac{PIDI}} genannt wird.
Abgesehen von einer effizienten Speichernutzung, soll das \ac{PIDI}-Format auch performant zum Ansteuern der Aktuatoren transformiert werden können und möglichst simpel zu benutzen sein.
Außerdem soll es trotz der starken Einschränkung auf diesen Anwendungsfall variabel genug sein, um für unterschiedliche Konfigurationen von Klavieren verwendbar zu sein.
Das ist deshalb sinnvoll, da es die Möglichkeit bietet, die Anzahl verbundener Tasten des Klaviers jederzeit zu verändern.
Während Testphasen müssen somit nicht alle Tasten des Klaviers über Aktuatoren anspielbar sein.
Auch kann das \ac{PIDI}-Format dann in ähnlichen Projekten mit einer womöglich anderen Anzahl anspielbarer Tasten auf dem Klavier verwendet werden.

Listing \ref{code:PidiCmd struct} zeigt die endgültige Datenstruktur, die für ein individuellen \lstinline{PidiCmd} gewählt wurde, in Form eines C-Bitfields.
Ein \lstinline{PidiCmd} stellt dabei das Anspielens eines Tons dar.
Die Töne selbst wurden als ein Paar aus Oktave und Taste in der Oktave dargestellt, da die Anzahl Tasten in einer Oktave auf praktisch allen Klavieren gleich ist.
Die nullte Oktave bezeichnet hierbei die mittlere Oktave des Pianos, während positive und negative Zahlen in Relation zur mittleren Oktave zu verstehen sind.
Mit jeweils 4 Bits können alle 12 Tasten in einer Oktave und alle Oktaven, die auch auf großen Klavieren Platz finden, verwendet können.

Die \enquote{velocity} eines \lstinline{PidiCmd}s gibt die Anschlagsstärke an.
Um Speicherplatz zu sparen und da genauere Präzision beim Anspielen sich auf Hardware-Seiten eh als Schwierigkeit ergeben hat (siehe Kapitel \ref{???}), wurde sich entschieden, nur 4 Bits für die \enquote{velocity} bereitzustellen.
Zuletzt gibt es dann noch die \lstinline{dt} und \lstinline{len}, die respektiv jeweils die Zeit seit der zuletzt gespielten Note und die Spiellänge der Note darstellen.
Während in \ac{MIDI} eine sehr hohe und dynamisch veränderbare Auflösung für die \enquote{delta time} verwendet wurde, ist \lstinline{dt} hier immer in Millisekunden enkodiert.
Mit den dafür allokierten 12 Bits können $\frac{2^{12}}{1000} = 4,096$ Sekunden ohne Anspielen eines neuen Tons enkodiert werden.
Da die Anspiellänge zusätzlich noch für jeden zurzeit gespielten Ton gespeichert werden muss, wurde entschieden genau 1 Byte dafür zu verwenden.
Dies erlaubt eine leichte und speicher-effiziente Nutzung außerhalb der \lstinline{PidiCmd}-Datenstruktur.
Da 8 Bits nur Spiellängen von bis zu $\frac{2^8}{1000} = 0,256$ Sekunden abspeichern können, wurde entschieden hier stattdessen eine Enkodierung in Centisekunden zu benutzen.
Damit können bis zu $\frac{2^8}{1000} = 2,56$ Sekunden abgespeichert werden.

Insgesamt benötigt ein \lstinline{PidiCmd} dann genau 4 Byte.
Damit passt die Datenstruktur gut in CPU-Register, was eine schnellere Benutzung ermöglicht.
Wenn davon ausgegangen wird, dass die meisten Töne mit einer Anspielstärke gespielt werden und ausklingen bevor sie mit einer anderen oder derselben Stärke wieder gespielt werden, dann benötigt \ac{MIDI} für jeden Ton mindestens 7 Bytes.
Dabei werden 4 Bytes zum initialen Anspielen und 3 Bytes zum Ausklingen des Tons verwendet.
\ac{PIDI} benötigt dagegen immer genau 4 Bytes für jeden Ton.
Damit ist verbraucht \ac{PIDI}-Format mindestens $\frac{7}{4} = 1,75$-Mal weniger Speicher als das \ac{MIDI}-Format.

\begin{UnbrokenCodePage}[style=CStyle, caption={Definition eines \ac{PIDI}-Kommands}, label={code:PidiCmd struct}]
typedef enum {
    PIANO_KEY_C,
    PIANO_KEY_CS,
    PIANO_KEY_D,
    PIANO_KEY_DS,
    PIANO_KEY_E,
    PIANO_KEY_F,
    PIANO_KEY_FS,
    PIANO_KEY_G,
    PIANO_KEY_GS,
    PIANO_KEY_A,
    PIANO_KEY_AS,
    PIANO_KEY_B,
} PianoKey;

typedef struct PidiCmd {
    uint32_t dt : 12,
    velocity    : 4,
    len         : 8,
    octave      : 4, // needs to be sign-extended when used, because it's a signed 4-Bit integer
    key         : 4;
} PidiCmd;
\end{UnbrokenCodePage}


\section{Logik des Microcontrollers} \label{vorgehenSW-MC}

Der \ac{MC} hat grundlegend zwei Aufgaben.
Einerseits muss der \ac{MC} Daten an die Aktuatoren senden, um das Klavier richtig anzuspielen.
Andererseits muss der \ac{MC} auch mit der \ac{UI} kommunizieren können.
Da der \ac{MC} nur einen einzelnen CPU-Kern hat, können diese Aufgaben nur abwechselnd nacheinander und nicht parallel bearebeitet werden.
Während die Anspiellogik in diesem Kapitel erläutert wird, soll die Kommunikation mit der \ac{UI} im nächsten Kapitel \ref{vorgehenSW-SPPP} dargelegt werden.

Um die richtigen Werte zu den Aktuatoren zu senden, müssen nacheinander alle Werte an die Schieberegister gegeben werden.
Der Wert des letzten Schieberegister-Ausgangs muss dabei zuerst gesendet werden, da es dann als erstes komplett durchgeschoben wurde.
Sobald alle Werte ausgesandt wurden, müssen die Ausgänge der Schieberegister gesperrt werden, damit diese nicht ständig fluktuieren.
All das kann beim Arduino, der in Kapitel \ref{Ansteuerung} als \ac{MC} gewählt wurde, über das Ansprechen spezieller \ac{PWM}-Pins getan werden.

% @TODO(Val): Absatz bzgl. Notwendigkeit von Interrupts beim Ansprechen von PWM einfügen

Wann immer die Signale für die Aktuatoren ausgesandt werden sollen, müssen diese Werte vorher bereitstehen.
Da 88 Aktuatoren angesteuert werden sollen, muss also eine Liste von 88 \ac{PWM}-Werten befüllt werden.
Im Folgenden soll diese Liste \lstinline{piano} genannt werden.
Um \lstinline{piano} zu befüllen müssen die Informationen des Musikstücks verwendet werden, die wie in Abschnitt \ref{vorgehenSW-PIDI} beschrieben, als eine Liste von \lstinline{PidiCmd}s gespeichert werden.

Die \lstinline{PidiCmd}-Struktur ist nicht nur sehr speichereffizient, sondern erlaubt auch eine performante Anpassung der \lstinline{piano} Liste.
Da die \lstinline{PidiCmd}s zeitlich sortiert sein müssen, reicht ein laufender Index in die Liste.
Um zu entscheiden, ob eine Note gespielt werden soll, wird außerdem die Zeit benötigt, die seit Spielen des letzten \lstinline{PidiCmd}s vergangen ist.
Außerdem muss überprüft werden, ob einige der zurzeit spielenden Töne wieder ausgeschaltet werden sollten.
Um dies schnell berechnen zu können, wird eine Liste mit allen zurzeit gespielten Noten gehalten.
Für jede Note wird dabei die Zeit gespeichert, für die sie noch weiterhin gespielt werden sollte.
Listing \ref{code:Apply PIDICmds} stellt diese Logik in Pseudocode dar.

\begin{UnbrokenCodePage}[style=CStyle, caption={Nutzung der \lstinline{PidiCmd}-Struktur}, label={code:Apply PIDICmds}]
PIDICmds *cmds; // assume this array to be initialized already
u8  piano[88];  // list of values to send to magnets
u32 index = 0;
while (true) {  // Endless Loop of Microcontroller
    u32 start_time   = currentTime(); // time in milliseconds
    u32 elapsed_time = 0;
    update_played_keys(elapsed_time);
    while (index < length(cmds) && cmds[index].dt <= elapsed_time) {
        applyCmd(piano, cmds[index]);
        elapsed_time -= cmds[index].dt;
        add_to_played_keys(cmds[index].dt);
        index++;
    }
    elapsed_time += getElapsedTimeSince(start_time);
}
\end{UnbrokenCodePage}

Die in Listing \ref{code:Apply PIDICmds} erwähnten Funktionen \lstinline{currentTime} und \lstinline{getElapsedTimeSince} sind über die eingebaute Uhr des \ac{MC} umsetzbar.
Die Funktion \lstinline{aplyCmd} setzt die Stärke des Tastenanschlags an der richtigen Stelle in der \lstinline{piano} Liste.
Da die \lstinline{PidiCmd}-Struktur die Anordnung und Anzahl verfügbarer Aktuatoren ignoriert, muss diese Umrechnung von Oktave und Ton in den genauen Aktutor, der diese Taste betätigt, hier geschehen.
Zuletzt verwendet das Listing noch die Funktionen \lstinline{update_played_keys} und \lstinline{add_to_played_keys}.
Diese benötigen eine Liste der zurzeit gespielten Töne.
Weil nur eine bestimmte Anzahl der Aktuatoren zu einem Zeitpunkt aktiv sein dürfen (siehe Kapitel \ref{???}), kann diese Liste klein gehalten werden.

Sollte ein Musikstück diese Obergrenze zu gleichzeitig zu spielender Noten überschreiten wollen, müssen einige Töne früher beendet werden als eigentlich abgesehen.
Hier gibt es mehrere Strategien, die jeweils eigene Vor- und Nachteile mit sich bringen.
Die am leichtesten zu implementierende Idee, würde neue Noten einfach nicht spielen lassen.
Entweder könnten diese neuen Noten übersprungen werden, oder es könnte gewartet werden, bis eine der zurzeit spielenden Noten wieder ausklingen sollen, bevor weitere \lstinline{PidiCmd}s überhaupt betrachtet werden.
Letztere Strategie würde quasi die Geschwindigkeit des Musikstücks kurzzeitig anpassen und eher ungewollte Anpassungen an der Natur des Stücks vornehmen.
Um den Nachteil der ersten Strategie aufzuzeigen, soll ein Beispiel verwendet werden.

Angenommen es dürfen nur 5 Aktuatoren auf einmal aktiviert werden.
Nun werden gerade C, D, E, F und G der mittleren Oktave gespielt.
Das C soll nur noch für ein paar Millisekunden gespielt werden.
Davor soll aber nun ein B gespielt werden.
Dieses B soll nun für eine ganze Sekunde gespielt werden.
Optimal wäre es hier, das C, das sowieso bald ausklingen soll, ein paar Millisekunden früher zu auszuschalten, dami das B zum richtigen Zeitpunkt schon gespielt werden kann.
Die zuerst genannte Strategie würde dagegen das C einfach überhaupt nicht spielen.

Aus diesem Beispiel lässt sich eine alternative Strategie entwickeln.
So lassen sich die Längen, für die die bereits gespielten Töne und den neu zu spielenden Ton vergleichen.
Die Töne, die am frühesten wieder ausklingen sollen, können dann bereits ein wenig früher abgebrochen werden.
Da die Liste bereits gespielter Töne kurz sein muss, ist eine Iteration über alle bereits gespielten Töne nicht besonders zeitaufwendig.
Nichtsdestotrotz ist dieses Vorgehen komplizierter und rechenaufwendiger als die beiden erstgenannten Ideen.

Eine weitere Möglichkeit wäre statt der Länge die Anschlagsstärken zu vergleichen.
Es kann davon ausgegangen werden, dass das Fehlen stärker zu spielender Töne eher schlecht auffallen würde als das Fehlen leiserer Töne.
Es ließe sich auch eine Heuristik erstellen, die sowohl die Anschlagsstärke als auch die noch verbleibende Spiellänge mit einander vermischt.
Ohne Testen an realen Musikstücken, ist es jedoch schwer zu sagen, wie eine solche Heuristik aussehen sollte.
Hier ist es also sinnvoll eine leicht anpassbare Heuristik zu verwenden und während des Testens dann zu analysieren, welche Heuristik am besten klingende Resultate mit sich bringt.

% @TODO(Val): Spezifiziere diese Anforderungen auch wirklich in Kapitel Zielstellung
Die benötigte Logik zum Anspielen des Klaviers ist damit fast vollständig besprochen.
Es fehlt jedoch noch die Logik zum dynamischen Anhalten und Anpassen der Lautstärke und Spielgeschwindigkeit, die in Kapitel \ref{Zielstellung} spezifiziert wurden.

Das Anhalten kann über eine einfachen Bool'schen Wert gelöst werden.
Wenn angehalten wurde, soll statt den Werten aus der \lstinline{piano} Liste, eine Null an jeden Aktuator gesendet werden.
Auch sollen keine weiteren \lstinline{PidiCmd}s angewandt werden.

Die Lautstärke ist über Erhöhen der Anschlagsstärke umsetzbar.
Da \lstinline{PidiCmd}s die Anschlagsstärke in einem abstrakten Wert von 0 bis 15 darstellen, kann dieser Wert über einen Lautstärke-Faktor skaliert einfach skaliert werden.

Die Geschwindigkeit kann ebenfalls über einen Faktor implementiert werden.
Dieser Faktor skaliert dabei jedoch die Messung der vergangenen Zeit.
Hierbei ist aufzupassen, dass nicht die in Listing \ref{code:Apply PIDICmds} verwendete Variable \lstinline{elapsed_time} skaliert wird, sondern der Term \lstinline{getElapsedTimeSince}, der zur \lstinline{elapsed_time} hinzu addiert wird.
Ansosten würde nämlich die akkumulierte Zeit der Vergangenheit angepasst werden, statt die Geschwindigkeit der zurzeit laufenden Zeit zu verändern.


\section{UI-Arduino Kommunikation} \label{vorgehenSW-SPPP}

Den in Kapitel \ref{Zielstellung} gestellten Anforderungen nach, soll über die \ac{UI} das automatisch gespielte Musikstück dynamisch wählbar sein.
Das bringt mit sich, dass die \ac{UI} Daten an den \ac{MC} senden können muss.
Abgesehen von den zu spielenden Noten, muss die \ac{UI} dem \ac{MC} auch mitteilen können, ob angehalten werden soll, oder sich Lautstärke oder Geschwindigkeit angepasst wurden.

% @TODO(Val): Source for why these questions in particular maybe
Hierbei sollten mehrere Fragen aufkommen:
\begin{enumerate}
    \item Geht die Kommunikation in beide Richtungen oder nur von der \ac{UI} zum \ac{MC}?
    \item Welche Medien sollen für die Kommunikation unterstüzt werden?
    \item Soll die Kommunikation seriell oder parallel ablaufen?
    \item Über welches Protokoll werden die Daten enkodiert?
    \item Soll die Kommunikation synchron, asynchron oder isochron ablaufen?
    \item Wie wird Datenkonsistenz sichergestellt?
    \item Wie wird Datenvollständigkeit sichergestellt?
    \item Wie wird mit Fehlern umgegangen?
% @Note(Val): Die Arten von Kommunikation (seriell/parallel, (asyn-/syn-/iso-)chron) erklär ich hier nicht, da wir bei Leser:innen von einem Wissenstand einer generellen IT Bachelor Student:in ausgehen.
\end{enumerate}

Zuerst mag eine einseitige Kommunikation ausreichend erscheinen.
Allerdings erlaubt eine zweiseitige Kommunikation bessere Portabilität der Anwendung.
So muss die \ac{UI} wissen, über welchen Port der \ac{MC} angesprochen werden kann.
Da nicht alle Maschinen die gleichen Ports zur Verfügung stehen haben, sollte dieser Port dynamisch wählbar sein.
Um den korrekten Port entsprechend auch dynamisch finden zu können, muss der \ac{MC} ein einzigartiges Signal über den Port zu der \ac{UI} schicken können.
Hier kann beispielsweise ein spezielles \enquote{PING}-Signal über jeden verfügbaren Port geschickt werden.
Während der \enquote{PING} von anderen Ports ignoriert wird, kann der \ac{MC} mit dem entsprechenden \enquote{PONG}-Signal antworten.
Somit kann die \ac{UI} jederzeit die Verfügbarkeit des \ac{MC}s und dessen Port prüfen.

Mögliche Übertragungsmedien für die Kommunikation lassen sich in die Kategorien \enquote{Kabel} und \enquote{Kabellos} einteilen.
Kabellose Medien wie WLAN oder Bluetooth benötigen bei dem in Kapitel \ref{???} gewählten \ac{MC} ein weiteres Modul.
Das würde die Kosten weiter erhöhen und damit entgegen dem Ziel einer möglichst preisgünstigen Entwicklung sprechen.
Nichtsdestotrotz sollte die Kommunikation erweiterbar konzipiert werden, um auch leicht kabellos umgesetzt werden zu können.
Da es im gewählten \ac{MC} jedoch schon eingebaut ist und damit die preisgünstigste Möglichkeit darstellt, soll hier eine Verbindung über ein USB-Kabel zwischen \ac{MC} und \ac{UI} angenommen werden.

Damit wird auch die nächste Frage bereits beantwortet, da über das USB-Kabel nur eine serielle Kommunikation möglich ist.
Der gewählte \ac{MC} schränkt auch die möglichen Protokolle zur Übertragung von Daten ein.
So unterstützt der Arduino Uno R3 nur die folgenden drei Übertragungsprotokolle:
\begin{enumerate}
    \item \ac{I2C}
    \item \ac{SPC}
    \item \ac{UART}
\end{enumerate}
\ac{I2C} und \ac{SPC} sind beides Protokolle, die für die Kommunikation mit Periphergeräten gedacht wurden.
\ac{UART} wird dagegen von Arduino Dokumentation für generelle Kommunikation mit einem PC empfohlen. % @TODO(Val): Source - Documentation/Examples
Da die Desktop-Anwendung das selbe Protokoll sprechen können muss, ist die Nutzung von \ac{UART} auch insoweit sinnvoll, dass Windows nativ die Nutzung des \ac{UART}-Protokolls über sogenannte \enquote{COM}-Ports ermöglicht.
Da \ac{UART} verwendet wird, steht auch fest, dass die Übertragung von Daten asynchron abläuft.

% @Note(Val): Sollte erwähnt werden, dass UI & MC die selbe Baud-Rate, Daten-Bit-Siue, etc. haben müssen?
% Siehe List hier: https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#Transmitting_and_receiving_serial_data
Das \ac{UART}-Protokoll bringt auf Level der Bit-Übertragung bereits Mechanismen zum Sicherstellen der Datenkonsistenz und Vollständigkeit mit sich. % @Note(Val): Mention what mechanisms these are maybe
Bis jetzt wurde jedoch nur geklärt wie die Bits der Nachrichten übertragen werden, nicht jedoch wie diese Nachrichten aussehen sollen.
Das benötigt ein weiteres Protokoll, das diesmal jedoch über Software in den Anwendungen des Arduinos und Desktops implementiert werden muss.
Im Folgenden soll dieses Protokoll \enquote{\ac{SPPP}} genannt werden.

Es wäre hierbei möglich ein bereits existierendes, generelles Kommunikationsprotokoll zu verwenden.
Zum Beispiel könnten die Daten über das \ac{HTTP} gesendet werden.
Jedoch muss selbst dann noch ein spezielles Schema spezifiziert werden, in dem die Daten angeordnet werden.
Entsprechend ist es sinnvoll hier ein eigenes, einfaches Protokoll zu entwerfen, dass alle Anforderungen an die Kommunikation abdecken kann.
Dabei muss das \ac{SPPP} die folgenden Anforderungen erfüllen, welche basierend auf den in Kapitel \ref{Zielstellung} gestellten Anforderungen abgeleitet wurden.

\begin{enumerate}
    \item Die \ac{UI} muss einen \enquote{Ping} senden können, auf die der \ac{MC} mit einem \enquote{Pong} antwortet, damit der genaue Port, an dem der Arduino ist, identifiziert werden kann.
    \item Die \ac{UI} muss dem \ac{MC} sagen können, dass die Musik angehalten oder fortgesetzt werden soll
    \item Die Lautstärke muss von der \ac{UI} an den \ac{MC} gesendet werden können
    \item Die Geschwindigkeit muss von der \ac{UI} an den \ac{MC} gesendet werden können
    \item Musikdaten in Form von \lstinline|PidiCmd|s muss von der \ac{UI} an den \ac{MC} gesendet werden können
    \item Die \ac{UI} muss dem \ac{MC} sagen können, dass zu einem beliebigen Zeitpunkt im Musikstück gesprungen werden soll
    \item Fehler in der Kommunikation sollten erkannt werden, damit \ac{UI} und \ac{MC} diese entsprechen behandeln können
    \item Die Latenz beim Senden von Nachrichten sollte möglichst gering und mindestens unter einer Sekunde sein
    \item Das Protokoll soll erweiterbar sein, sodass leicht weitere Versionen erstellt werden können, ohne Backwards-Compatibility zu brechen
\end{enumerate}

Aus den Anforderungen wird klar, dass es unterschiedliche Arten an Nachrichten gibt, die vom Protokoll unterstützt werden müssen.
Eine entsprechend simpler Aufbau von \ac{SPPP} Nachrichten besteht aus einer ID, die den Typ der Nachricht identifiziert, und einem Datensatz, der je nach Nachrichten-Typ unterschiedlich spezifiziert ist.
Damit lässt sich das Protokoll auch leicht erweitern, da neue Nachrichten-Typen einfach hinzugefügt werden können.
Es empfiehlt sich außerdem jede Nachricht mit bestimmten \enquote{Magic Bytes} zu starten, um keine arbiträren Datenströme als Nachrichten zu interpretieren.

Um die Latenz der Nachrichten unabhängig technisch Gegebenheiten gering zu halten, empfiehlt es sich, die Anzahl zu übertragener Bytes möglichst gering zu halten.
Entsprechend wurde entschieden, die IDs der Nachrichten-Typen auf jeweils ein einzelnes Byte zu reduzieren.
Zur leichteren Identifizierung werden Nachrichten-IDs nur ASCII-enkodierte Buchstaben verwendet.
Weiterhin wird hier die Konvention eingeführt, dass Großbuchstaben eine Nachricht der \ac{UI} und Kleinbuchstaben eine Nachricht des \ac{MC}s spezifzieren.

Die Magic Bytes des Protokolls werden als die 3-Byte Sequenz \enquote{SPP} definiert.
Ein einzelnes Byte wäre zu unsicher, da jedes zufällig empfangene Byte eine $\frac{1}{256} = 0,39\%$ Chance hat das Magic Byte zu sein.

Die meisten Nachrichten müssen jeweils nur eine einzelne Zahl übersenden.
Tabelle \ref{table:SPPP-Messages} listet alle Nachrichtentypen mit ihren jeweils zu übertragenen Daten auf.

\begin{table}[htbp]
    \centering
    \begin{tabular}{|p{6mm}|p{80mm}|p{55mm}|}
        \theadstart{ID} & \theadcol{Beschreibung} & \theadcol{Payload} \\ \hline
        \enquote{P} & \enquote{Ping}-Nachricht & - \\ \hline
        \enquote{p} & \enquote{Pong}-Nachricht - Antwort vom \ac{MC} auf Ping-Nachricht & Maximal-Anzahl von \lstinline|PidiCmd|s pro \enquote{Music}-Nachricht \\ \hline
        \enquote{C} & \enquote{Continue}-Nachricht, zum Anhalten bzw. Fortsetzen der Musik & 1 Byte; Nur bei 0 soll die Musik angehalten werden \\ \hline
        \enquote{V} & \enquote{Volume}-Nachricht - setzt die Lautstärke & 32-bit Floating-Point Wert \\ \hline
        \enquote{S} & \enquote{Speed}-Nachricht - setzt die Abspielgeschwindigkeit & 32-bit Floating-Point Wert \\ \hline
        \enquote{s} & \enquote{Success}-Nachricht - Antwort vom \ac{MC} auf jede erfolgreich erhaltene Nachricht & - \\ \hline
        \enquote{M} & \enquote{Music}-Nachricht & siehe Abschnitt \ref{SPPP-Pidi-Messages} \\ \hline
        \enquote{N} & \enquote{New-Music}-Nachricht & siehe Abschnitt \ref{SPPP-Pidi-Messages} \\ \hline
        \enquote{r} & \enquote{Request}-Nachricht - vom \ac{MC} geschickt (siehe Abschnitt \ref{SPPP-Pidi-Messages}) & - \\ \hline
    \end{tabular}
    \caption{\ac{SPPP}-Nachrichten}
    \label{table:SPPP-Messages}
\end{table}
% @TODO(Val): Update code & Protocol-Specification to fit this description
% @TODO(Val): Update magic bytes to be `SPP`
% @TODO(Val): Put full Spec in Appendix

\subsection{Fehlerbehandlung} \label{SPPP-Error-Handling}

% @Note(Val): Einleitung hier redet von 'Erkennung' der Fehler, Subsection-Titel ist aber 'Fehlerbehandlung' - da sollte eins von beiden wahrscheinlich gefixt werden
Wie in den oben gelisteten Anforderungen erwähnt, benötigt es jedoch noch eine Möglichkeit Fehler in der Kommunikation zu erkennen.
Es gibt hierbei grundsätzlich drei Arten an potenziellen Fehlern:

\begin{enumerate}
    \item Inkorrekte Daten werden empfangen
    \item Die Nachricht wird nicht empfangen
    \item Teile der Nachricht werden nicht empfangen
\end{enumerate}

Die erste Art an Fehlern soll hier erstmal ignoriert werden, da sie dank der von USB und \ac{UART} versicherten Datenkonsitenz ein relativ geringes Eintrittsrisiko darstellt.
Nichtsdestotrotz ist dies eine mögliche Fehlerquelle, die in Erweiterungen an diese Arbeit ausgebessert werden sollte. % @TODO(Val): Bei Limitationen erwähnen
Eine mögliche Sicherstellung der Datenkonsistenz würde beispielsweise über das Mitsenden eines Kontroll-Bytes.

Der zweite Fehler kann sowohl durch Fehler in der Übertragung, als auch durch ein Fehler bei der Software des Empfängers entstehen.
Eine einfache Lösung dieses Problems, lässt den Empfänger eine Empfangsbestätigung zurücksenden.
Das selbe Prinzip wird bei der oben erwänten \enquote{Ping} und \enquote{Pong}-Nachricht verwendet.
Ein mögliches Problem beim Senden einer Empfangsbestätigung ist die Ungewissheit, ob die Empfangsbestätigung selbst empfangen wurde.
Dann müsste nämlich eine Empfangsbestätigung für die Empfangsbestätigung gesendet würde, welche ebenfalls wieder als empfangen bestätigt werden müsste, bis nur noch Empfangsbestätigungen hin und her geschickt würden.

Es stellt sich jedoch heraus, dass das hier kein Problem ist.
Sollte eine Empfangsbestätigung nicht empfangen werden, muss der Sender die selbe Nachricht nochmal senden.
Solange das zweimalig Erhalten der selben Nachricht genau die selben Auswirkungen hat wie das einmalige Erhalten der Nachricht, wird keine Empfangsbestätigung für die Empfangsbestätigung selbst benötigt, da die Nachricht ohne Risiken einfach nochmal geschickt werden kann.
Wenn die in Tabelle \ref{table:SPPP-Messages} gelisteten Nachrichtentypen betrachtet werden, fällt außerdem auf, dass nur die Nachrichten, die von der \ac{UI} gesendet werden, eine Empfangsbestätigung benötigen.
Diese Bestätigung soll über die \enquote{Success}-Nachricht gegeben werden, welche entsprechend nur vom \ac{MC} geschickt werden muss.

Ein weiteres Problem, das mit Empfangsbestätigungen auftreten kann, ist das Zurordnen der Nachricht, die nun als empfangen bestätigt wurde.
Sollte die \ac{UI} beispielsweise zwei Nachrichten direkt nacheinander schicken und dann nur eine einzelne \enquote{Success}-Nachricht zurück erhalten, ist unklar welche der beiden Nachrichten nun angekommen ist und welche nicht.
Dies kann gelöst werden, indem jeder Nachricht eine einzigartige Nummer zugeordnet wird und die \enquote{Success}-Nachricht diese Nummer referenziert.

Alternativ kann auch einfach spezifziert werden, dass eine neue Nachricht nur gesendet werden darf, wenn eine \enquote{Success}-Nachricht erhalten wurde oder eine gewisse Zeit vergangen ist.
Diese Zeit wird auch als \enquote{Timeout} benannt. % @TODO(Val): Mention other protocols (like HTTP, Websockets, etc.) using timeouts like this too
Die zweite Methode bringt mit sich, dass das \ac{SPPP} Protokoll synchron wird und mag deshalb weniger flexibel als die asynchrone, erste Lösungsvariante erscheinen.
Allerdings erleichtert die Synchronisierung des Protokolls auch den Umgang mit dem 3. Fehler, wie nachher gezeigt wird.
Entsprechend wird sich für diese Lösungsmöglichkeit entschieden.

Weiterhin sollte die Frage aufkommen, warum statt einer eigenen \enquote{Pong}-Nachricht nicht einfach die selbe \enquote{Success}-Nachrich gesendet werden kann, wenn der Austausch von \enquote{Ping}- und \enquote{Pong}-Nachrichten genauso dem Prinzip der Empfangsbestätigung folgt.
Der Grund dafür liegt in den \enquote{Music}-Nachrichten, die eine variable Länge haben.
Da dieses Protokoll - wie auch das in Kapitel \ref{vorgehenSW-PIDI} spezifzierte \ac{PIDI}-Format - portabel für verschiedene Hardware-Voraussetzungen sein soll, kann die \ac{UI} nicht die Speicherkapazitäten des \ac{MC}s voraussetzen.
Entsprechend muss der \ac{MC} der \ac{UI} irgendwie mitteilen, was die akzeptierte Maximallänge für die \enquote{Music}-Nachricht ist.
Da die \enquote{Ping}-Nachricht im Regelfall sowieso die zuerst gesendete Nachricht wäre, kann der \ac{MC} deren Empfangsbestätigung nutzen, um der \ac{UI} dieses Maximum mitzuteilen.
Damit ist die \enquote{Ping}-Nachricht nun notwendigerweise die zuerst gesendete Nachricht in diesem Protokoll.

Es bleibt nun noch der 3. Fehler zu behandeln.
Wenn ein Teil der gesendeten Nachricht ausfällt, gibt es zwei Möglichkeiten.
Entweder werden weitere Bytes empfangen, sodass eine scheinbar vollständige, wenn auch inkorrekte Nachricht erhalten wird.
Das ist im Endeffekt wieder das 1. Problem und wird ebenso im Rahmen dieser Arbeit ignoriert.
Weitere Versionen des Protokolls sollten diese Quellen möglicher Dateninkonsistenz jedoch behandeln.
Es ist allerdings auch möglich, dass keine weiteren Bytes empfangen werden und die Nachricht unvollständig bleibt.
Da das Protokoll synchron ist und keine weiteren Nachrichten gesendet werden sollten, bevor Empfangsbestätigung zurückgeschickt wurde, ist dies tatsächlich der sehr viel wahrscheinlichere Fall.
Da für die Behandlung des 2. Problems sowieso schon ein Timeout festgelegt werden muss, kann dieser Timeout hier ebenfalls verwendet werden.
Sobald der Timeout abgelaufen ist und die Nachricht noch nicht vollständig empfangen wurde, soll diese einfach verworfen werden.
Sollten die fehlenden Bytes nach Ablauf des Timeouts eintreffen, werden diese ignoriert, da sie sehr wahrscheinlich nicht mit den Magic-Bytes des \ac{SPPP} Protokolls beginnen.

In den oben genannten Anforderungen wurde die maximale Latenz für Nachrichten auf 1 Sekunde gesetzt.
Diese Anforderung kann eins-zu-eins als Wert des Timeouts von \ac{SPPP}-Nachrichten übernommen werden.
Die \ac{UI} muss dabei jedoch den doppelten \ac{Timeout} als Wert nehmen, da sie zusätzlich noch auf den Eingang der Empfangsbestätigung warten muss.

\subsection{\enquote{Music}-Nachrichten} \label{SPPP-Pidi-Messages}

Die grundlegende Aufgabe, für die die Kommunikation zwischen \ac{UI} und \ac{MC} benötigt wird, ist das Transferieren der zu spielenden Musikdaten.
Wie in Kapitel \ref{vorgehenSW-MC} beschrieben, verwendet der \ac{MC} das selbst-erstellte \ac{PIDI}-Format zum Speichern der Musikdaten.
Entsprechend ist es sinnvoll, diese Daten direkt im gleichen Format an den \ac{MC} zu schicken.

Da der Speicherplatz des \ac{MC}s jedoch vergleichsweise stark begrenzt ist, können viele Songs nicht komplett gespeichert werden.
Auch wenn diese Limitation mit Erweiterungen der Hardware gelöst werden könnten, würden diese die Kosten weiter ansteigen.
Um den Ziel der Arbeit gerecht zu werden, darf ein großer Speicherplatz nicht vorausgesetzt werden.
Wenn also nicht davon auszugehen ist, dass das gesamte Musikstück auf einmal auf dem \ac{MC} gespeichert werden kann, müssen die Musikdaten in Teilen nach einander geschickt werden.
In anderen Worten: es ist ein Streaming der Musikdaten notwendig.

Eine erste Problematik, die hierbei aufkommt ist die Latenz der Nachrichten.
Wenn nach Spielen eines Teils des Songs immer eine längere Wartezeit folgt, bevor die nächsten Töne gespielt werden können, macht es das selbst-spielende Klavier praktisch unnutzbar.
Diese Problematik ist auch als \enquote{Buffering} bekannt. % @TODO(Val): Source for Buffering
Die einfachste Art dem Vorzeubugen ist durch die Verwendung von zwei Buffern für die \lstinline|PidiCmd|s.
Ein Buffer hält die derzeit zu spielenden \lstinline|PidiCmd|s, während der zweite Buffer mit den danach zu spielenden \lstinline|PidiCmd|s befüllt werden kann.
Sobald der erste Buffer fertig gespielt wurde, können die beiden Buffer effizient mit einem Tausch ihrer Pointer gewechselt werden.

Das Problem des Bufferings kann dann nur noch vorkommen, wenn der erste Buffer fertig gespielt wurde, bevor der nächste Buffer aufgefüllt werden konnte.
Eine einfache Verbesserung dieser Strategie ist die Nutzung von mehr Buffern als nur zwei.
Wenn drei Buffer genutzt werden, zum Beispiel, müssen zwei Buffer durchgespielt werden, bevor der nächste Buffer aufgefüllt werden muss.
Auch können die Buffer bereits getauscht werden, bevor die Nachricht fertig gelesen wurde, solange zumindest ein \lstinline|PidiCmd| bereits gelesen wurde.

Die nächste Schwierigkeit kommt daher, dass die \ac{UI} wissen muss, wann der nächste Teil des Musikstücks benötigt wird.
Die \ac{UI} könnte versuchen selbst die vergangene Zeit zu zählen und die selben Berechnung wie der \ac{MC} machen, um zu wissen, wieweit der \ac{MC} bis jetzt gespielt hat.
Falls hierbei jedoch ein Fehler auftritt, würde die Musikdaten zum falschen Zeitpunkt gesendet werden.
Abgesehen davon wäre dies auch ein relativ großer Entwicklungsaufwand.
Einfacher ist es, wenn der \ac{MC} eine bestimmte Nachricht schickt, um den nächsten Teil des Musikstücks anzufordern.
In Tabelle \ref{table:SPPP-Messages} ist diese Nachricht als \enquote{Request}-Nachricht spezifiziert.

Die \enquote{Request}-Nachricht ist die einzige Nachricht, die der \ac{MC} schickt, ohne auf eine Nachricht der \ac{UI} zu antworten.
Trotzdem muss die \ac{UI} hier nicht mit einer Empfangsbestätigung antworten, da sie sowieso mit einer Nachricht antwortet.
Nur ist die Antwort der \ac{UI} eine \enquote{Music}-Nachricht stattdessen.

Die \enquote{Request}-Nachricht enthält wie in Tabelle \ref{table:SPPP-Messages} spezifiziert keine weiteren Daten.
Das heißt, dass die \ac{UI} sich merken muss wie weit im Musikstück die letzte Nachricht fortgeschritten war.
Ein alternativer Ansatz würde den \ac{MC} speichern lassen, wie viele \lstinline{PidiCmd}s bereits gespielt wurden und würde diesen Index in der \enquote{Request}-Nachricht an die \ac{UI} schicken.
Beide Methoden nehmen sich nicht besonders viel, hier wurde sich jedoch für die erste Möglichkeit entschieden, da sie der \ac{UI} mehr Flexibilität bietet und weniger Daten übertragen werden müssen.

Die soweit beschriebene Strategie funktioniert zum Spielen vollständiger Stücke nacheinander.
Nun soll die \ac{UI} aber auch die Möglichkeit bieten, während des Spielen eines Stückes zu einem anderen zu wechseln.
In diesem Fall muss dem \ac{MC} mitgeteilt werden, dass ein neues Stück anfängt und alle Aktuatoren zu Beginn wieder ausgeschaltet werden sollen.

Zusätzlich soll es den Nutzer:innen möglich sein, in einem zurzeit spielenden Stück zu einem anderem Zeitpunkt zu springen.
In diesem Fall müssen die zurzeit aktiven Aktuatoren womöglich ebenfalls ausgeschaltet werden.
Jedoch ist es hier im Allgemeinen nicht der Fall, dass alle Aktuatoren ausgeschaltet werden sollten.
Die Aktuatoren der Noten, die bis zu dem gewählten Zeitpunkt gespielt werden sollen, müssen nämlich angeschaltet werden.
In Kapitel \ref{vorgehenSW-MC} wurde beschrieben, wie der \ac{MC} eine Liste bereits gespielter Noten für die selbe Problematik verwendet.
Es liegt entsprechend nahe, das selbe Konzept hier zu verwenden.
So kann ebenjene Liste direkt auf Seiten der \ac{UI} erstellt werden und zum \ac{MC} geschickt werden.

Es müssen hier jedoch noch die Elemente innerhalb dieser Liste spezifiziert werden.
Im Folgenden sollen diese Elemente als \lstinline|PlayedKey|s bezeichnet werden.
Wie in Listing \ref{code:Apply PIDICmds} auch, müssen die \lstinline|PlayedKey|s die verbleibende Länge, mit der der Ton gespielt werden soll, speichern.
Weiterhin muss auch die Stärke, mit der der Ton gespielt werden soll, gespeichert werden.
Die \lstinline|PlayedKey|-Struktur besteht entsprechend aus einer Referenz auf den Ton, der Länge und Spielstärke.
Wie im \ac{PIDI}-Format wird die anzuspielende Taste über Oktave und Note definiert.
Da Oktave, Note, Anspielstärke und Länge im \ac{PIDI}-Format jeweils als 4-Bit Zahlen spezifziert wurden, benötigt eine \lstinline|PlayedKey|-Struktur genau 2 Bytes.

Auf Seiten des \ac{MC}s ergibt es Sinn die Oktave und Note direkt in den Index für den zuständigen Aktuator zu transformieren, damit diese Berechnung nur einmal gemacht werden muss.
Ein weiterer Unterschied zwischen der \lstinline|PlayedKey|s Liste in der \enquote{Music}-Nachricht und auf dem \ac{MC} ist in der Länge der Liste.
Da der \ac{MC} nur eine bestimmte Anzahl gleizeitig spielender Tasten haben darf, ist die Länge dessen Liste beschränkt.
Da das \ac{SPPP} Protokoll ebenjene Feinheiten der Hardware abstrahieren soll, ist diese Limitierung in der \enquote{Music}-Nachricht nicht gegeben.
Sollten in der Nachricht also mehr \lstinline|PlayedKey|s sein, als der \ac{MC} gleichzeitig spielen darf, muss der \ac{MC} das gleiche Verfahren zum Eliminieren einiger \lstinline|PlayedKey|s anwenden, dass er auch sonst verwendet (siehe Kapitel \ref{vorgehenSW-MC}).

Da diese Liste nur übersendet werden muss, wenn ein neues Musikstück angefangen wird, oder zu einer anderen Stelle im spielende Stück gesprungen wird, gibt es zwei Möglichkeiten.
Entweder wird ein Byte in der \enquote{Music}-Nachricht eingefügt, dass klarstellt, ob die Liste von \lstinline|PlayedKey|s vorhanden ist oder nicht.
Oder es wird ein anderer Nachrichten-Typ dafür verwendet.
Letztere Strategie benötigt kein zusätzliches Byte in der Nachricht und wurde somit gewählt.
Dafür wird nun die \enquote{New-Music}-Nachricht verwendet.
Beim Eingang einer \enquote{New-Music}-Nachricht - anders als bei einer \enquote{Music}-Nachricht - ist es nicht erwünscht die zuvor eingegangenen \lstinline|PidiCmd|s noch fertig zu spielen.

Zuletzt mag noch die Frage aufkommen, was passieren soll, wenn das Musikstück fertig gespielt wurde.
Sollte es dafür ebenfalls einen eigenen Nachrichtentyp geben?
Das wäre eine simple Lösung, würde das Protokoll aber ein wenig verkomplizieren.
Sollte die \ac{UI} stattdessen die eingehenden \enquote{Request}-Nachrichten einfach ignorieren?
Dann würde der \ac{MC} endlos neue \enquote{Request}-Nachrichten schicken und somit unnötige Arbeit auf sich nehmen.
Stattdessen wurde entschieden, am Ende des Musikstücks eine \enquote{Music}-Nachricht mit einer leeren Liste von \lstinline|PidiCmd|s zu schicken.
Damit wid das \ac{SPPP} Protokoll nicht unnötig erweitert und der \ac{MC} muss nicht endlos neue Nachrichten schicken.
Der \ac{MC} sollte dann keine weiteren \enquote{Request}-Nachrichten schicken, sobald beide Buffer von \lstinline|PidiCmd|s leer sind.
Auf den ersten Blick mag das nach weiterer Arbeit klingen, diese Logik sollte zu Start des \ac{MC}s - bevor das erste Musikstück gespielt wurde - sowieso gelten.
Entsprechend ist es kein weiterer Aufwand in der Ausführung oder Entwicklung des \ac{MC}s.

\section{UI} \label{vorgehenSW-UI}
\begin{enumerate}
    \item UI Design-Plan
    \item Design Mock-Ups (?)
    \item Theoretische Grundlagen von UI
\end{enumerate}

Die Desktop-Anwendung soll den Nutzer:innen eine Schnittstelle zum Anspielen des Pianos bieten.
Zum Konzipieren der \ac{UI} sollten zuerst die Use Cases ausformuliert werden.
Zusätzlich sollten auch bestehende Standards von \ac{UI}s mit ähnlichen Use Cases beachtet werden, um eine intuitiv nutzbare Nutzeröberfläche für die gegebenen Use Cases zu erstellen.
