%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Autoren des Abschnitts:
%   Val Richter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% !TEX root =  master.tex
\chapter{Konzeption - Software} \label{vorgehenSW}
\chapterauthor{Val Richter}

Wie in Kapitel \ref{Zielstellung} beschrieben, soll eine Desktop-Anwendung für die Nutzer-Interaktion mit dem \enquote{Piano Player} erstellt werden.
Die Anwendung soll im Folgenden auch als \enquote{\acf{SAM}} bezeichnet werden.
Die fundamentale Aufgabe der Anwendung liegt im Verwalten und Spielen von Musikstücken auf dem selbstspielenden Klavier.
Zum Anspielen des Klaviers wird ein \ac{MC} benötigt (siehe Kapitel \ref{Ansteuerung}).
Da die Auswahl des Musikstücks dynamisch während der Laufzeit über \ac{SAM} gehen soll, muss \ac{SAM} mit dem \ac{MC} kommunizieren können.
In diesem Kapitel soll die Software beider Komponenten und deren Kommunikation konzipiert werden.

Abbildung \ref*{fig:high-level-komponenten} zeigt diese unterschiedlichen Komponenten, sowie den Datenfluss zwischen diesen.
Nutzer:innen werden in der Abbildung auch dargestellt, um eindeutig zu machen, dass Nutzer-Eingaben nur an \ac{SAM} gehen.
Der \ac{MC} erhält Daten zum abzuspielenden Musikstück von \ac{SAM} und schickt darauf basierend in regelmäßigen Intervallen \ac{PWM}-Signale an den \enquote{Piano Player}.

\begin{figure}[htbp]
    \centering
    \begin{tikzpicture}[node distance=2cm, line width=0.25mm]
        \node (user) [rect] {User};
        \node (ui) [rect, below of=user] {\ac{SAM}};
        \node (mc) [rect, right of=ui, xshift=1.5cm] {\ac{MC}};
        \node (hw) [rect, right of=mc, xshift=1.5cm] {Piano Player};

        \draw [arrow] (user) -- (ui);
        \draw [arrow] (ui)   -- (mc);
        \draw [arrow] (mc)   -- (hw);
    \end{tikzpicture}
    \caption{Komponenten-Diagramm mit Datenfluss}
    \label{fig:high-level-komponenten}
\end{figure}

Da die Hardware-Komponente in vorherigen Kapiteln bereits behandelt wurde, soll hier nur die Architektur der Desktop-Anwendung (in Abschnitt \ref{vorgehenSW-UI}) und des \ac{MC}s (in Abschnitt \ref{vorgehenSW-MC}) erarbeitet werden.
Dabei soll zuletzt noch die Kommunikation zwischen diesen beiden Komponenten in Abschnitt \ref{vorgehenSW-SPPP} betrachtet und spezifiziert werden.
Ein Ziel der Kommunikations-Spezifikation ist eine leichte Anpassbarkeit der einzelnen Komponenten, solange sie sich weiterhin an das selbe Kommunikations-Protokoll halten.
Damit soll der Anforderung A8 gerecht werden.

Weiterhin soll auch das Format, in dem Musikstücke auf dem \ac{MC} gespeichert werden, in Abschnitt \ref{vorgehenSW-PIDI} entworfen werden.
Da der \ac{MC} eine möglichst hohe Geschwindigkeit für die Ansteuerung der Motoren erbringen soll, muss das Format eine performante Nutzung ermöglichen.
Auch muss das Format möglichst wenig Speicherplatz aufbrauchen, damit möglichst viele Daten auf einmal auf dem \ac{MC} gespeichert werden können.
Je mehr Speicherplatz das Format nämlich benötigt, desto öfter muss die \ac{UI} Daten an den \ac{MC} schicken, was aufgrund relativ hoher Latenzen in der Kommunikation nicht wünschenswert ist.


\section{Desktop Anwendung} \label{vorgehenSW-UI}

\ac{SAM} soll den Nutzer:innen eine Schnittstelle zum Anspielen des Pianos bieten.
Den in Tabelle \ref{table:anforderungen} genannten Anforderungen nach, soll es der Nutzer:in möglich sein Musikstücke aus einem Katalog auszuwählen (A9) und dem Katalog neue Stücke hinzuzufügen (A12).
Weiterhin soll die Wiedergabe über die \ac{UI} steuerbar sein (siehe Anforderungen A10 und A11). \newline
In diesem Kapitel \ac{SAM} sowhol in Hinblick auf Code-Architektur (Abschnitt \ref{vorgehenSW-UI-code}) als auch auf das \ac{UI} Design (Abschnitt \ref{vorgehenSW-UI-design}) ein Konzept entwickelt werden.


\subsection{UI Design} \label{vorgehenSW-UI-design}

Aus Sicht der Nutzer:innen hat \ac{SAM} zwei Aufgaben:
\begin{enumerate}
    \item Musik-Verwaltung
    \item Musik-Wiedergabe
\end{enumerate}

Die Musik-Verwaltung beinhaltet das Hinzufügen neuer Musikstücke und die Darstellung des Katalogs.
Um auch die Nutzung eines großen Katalogs leicht zu ermöglichen, soll es eine Möglichkeit zum Suchen von Musikstücken nach Namen geben.
Bei der Musik-Wiedergabe muss dagegen mit dem \ac{MC} und somit indirekt mit dem Piano kommuniziert werden.
Auch sollen Kontrollmöglichkeiten bei der Wiedergabe zur Verfügung stehen.

Der Haupt-Use-Case besteht hierbei im Suchen und nachfolgendem Abspielen eines Musikstücks, während das Hinzufügen neuer Musik zum sofortigen oder späteren Abspielen einen zweiten Use-Case abbildet.
Diese Rangfolge der Use Cases sollte auch im Design der \ac{UI} wiedergespiegelt sein. \newline
Ein Ansatz dafür wäre die Teilung der \ac{UI} in zwei Seiten, wobei die erste, im Normalfall angezeigte Seite den Katalog darstellt, und die zweite Seite den Import von Musikstücken behandelt.
Alternativ könnten beide Funktionalitäten auch auf einer einzelnen Seite untegebracht werden mit der Gefahr, die \ac{UI} damit zu überladen. \newline
Die selbe Frage stellt sich ebenso für die Wiedergabe.
Diese kann entweder auf der selben Seite oder auf einer seperaten Seite untergebracht werden.

Da die Anwendung möglichst intuitiv und leicht erlernbar sein soll (siehe Anforderung A2), ist es bei diesen Fragen sinnvoll, ein ähnliches Design zu populären Musik-Playern zu verwenden.
Hier sollen vor allem der \enquote{\acf{WMP}}\footnote{\url{https://support.microsoft.com/en-us/windows/get-windows-media-player-81718e0d-cfce-25b1-aee3-94596b658287}} und \enquote{Spotify}\footnote{\url{https://www.spotify.com}} zum Vergleich gezogen werden.
Es ist davon auszugehen, dass die meisten Nutzer:innen mit mindestens einer der beiden Anwendungen vertraut sind.

Sowohl \ac{WMP} als auch Spotify bieten die Möglichkeit zum Betrachten von Katalogen - sogenannten Playlists - an.
Beide bieten auch die Möglichkeit an, mehere Playlists zu erstellen.
Im Rahmen dieser Arbeit soll eine solche Funktionalität nicht angeboten werden.
Stattdessen soll \ac{SAM} nur einen einzigen Katalog zur Verfügung stellen.
\ac{WMP} und Spotify bieten außerdem beide die Möglichkeit zum Abspielen von Musik.

Das Öffnen beider Anwendung liefert eine Startseite, der u.a. auf die unterschiedlichen, vorhandenen Playlists verlinkt.
Da \ac{SAM} nur einen Katalog anbietet, wäre dies unnötig und würde die Nutzung der Anwendung nur verlangsamen.
Stattdessen soll auf der Startseite der Katalog direkt gezeigt werden.

Beim Abspielen der Musik soll wie bei \ac{WMP} und Spotify auch eine Timeline des Musikstücks am unteren Fensterrand angezeigt werden.
Dabei soll eine Navigation im Musikstück über Klicken auf der Timeline möglich sein.
Die Kontroll-Elemente, die zum Erfüllen der Anforderungen A10 und A11 benötigt werden, sollen wie in Spotify oberhalb der Leiste dargestellt werden und ähnliche Symbole verwenden.

Anders als \ac{WMP} oder Spotify soll \ac{SAM} in der Lage sein, die Wiedergabegeschwindigkeit anzupassen (siehe Anforderung A10).
Dafür könnte entweder ein Slider verwendet werden, wie es auch bei der Konfiguration der Lautstärke üblich ist, oder über Buttons, die die Geschwindigkeit um eine feste Größe de- bzw. inkrementiert, wie es beispielsweise im populären Multi-Media-Spieler \enquote{VLC media player}\footnote{\url{https://www.videolan.org/vlc/}} gelöst ist.
Da anzunehmen ist, dass Buttons leichter als ein Slider zu implementieren sind, wurde sich im Rahmen des Prototypen entschieden, die Wiedergabegeschwindigkeit über Buttons steuern zu lassen.

Zuletzt ist nun noch das Hinzufügen von Musikstücken zu beachten.
Da das Importieren neuer Musikstücke einen zweitrangigen Use-Case darstellt, wurde sich entschieden, diesen auf einer zweiten Seite umzusetzen.
Viele bekannte Anwendungen, bei denen das Hochladen bzw. Importieren von Dateien ebenfalls nicht den primären Use-Case darstellt, lösen dies genauso. % @TODO(Val): Beispiele in Klammern/Fußnote erwähnen
Auf der Startseite soll ein Button zum Importieren exisiteren,der dann zur zweiten Seite führt, wo die zu importierende Datei ausgewählt werden kann, und für den Import umbenannt werden kann.

Es soll der Nutzer:in generell die Möglichkeit gegeben werden, jedes Musikstück im Katalog zu jedem Zeitpunkt umzubenennen und auch wieder zu entfernen.
Diese Änderungen sollten dabei durch Eingaben direkt beim dargestellten Musikstück möglich sein.
Das verhilft laut dem \ac{UI} Design Pattern \enquote{Make it direct} eine intuitivere Nutzung zu gestalten.
Beim Darstellen der Musikstücke sollte entsprechend der Name angezeigt werden, sowie eine Möglichkeit zum Abspielen, Anpassen des Namens und zum Löschen des Musikstücks.

Zuletzt ist beim Import noch zu beachten, dass die Nutzer:innen jederzeit den Import abbrechen können sollten.
Da der Import die Nutzer:in auf eine neue Seite bringt, soll das Abbrechen über einen links-gerichteten Pfeil gekennzeichnet werden, welches ein gängiges Symbol zum Rückkehren auf die vorherige Seite darstellt. % @TODO(Val): Beispiele in Klammern/Fußzeile erwähnen


\subsection{Architektur} \label{vorgehenSW-UI-code}

Um eine sinnvolle Architektur für die Desktop Anwendung zu erstellen, soll hier ein \enquote{Bottom Up} Ansatz genutzt werden.
Dabei wird beim Start der Anwendung angefangen und dann jeder \enquote{Codepath}, der aufgrund von Nutzer-Interaktionen oder sonstigen Effekten auftreten kann, Schritt für Schritt analysiert.
Funktionalitäten die benötigt werden, werden dabei benannt und können zusammengeführt werden, wenn die selbe oder eine ähnliche Funktionalität an anderer Stelle wieder benötigt wird.
Gleichzeitig wird auch notiert, welche Daten zu welchem Zeitpunkt vorliegen müssen und wie diese von einander abhängen. \newline
Dieser Ansatz wurde von Casey Muratori \enquote{Semantic Compression} getauft \cite[vgl.][]{mur.SemanticCompression.14}\footnote{Muratori spricht von Semantic Compression speziell bei der Entwicklung, jedoch wird in seiner Erklärung klar, dass er keinen vorherigen Schritt für die Konzeption der Architektur als notwendig sieht. Hier soll zwar der selbe Ansatz verwendet werden, aber mit einer Trennung des Entwurfs von der Implementierung.}.

Mit \enquote{Codepath} ist hier eine endliche, serielle Liste von Instruktionen gemeint.
Dabei ist zu beachten, dass auch eine mehrfach ausführende Schleife oder ein \lstinline|if-else| Block eine Liste von Instruktionen erstellt, die von der CPU augeführt werden können \cite[vgl.][]{fle.TaxonomyComputationShapes.23}. \newline
Eine Endlosschleife dagegen erzeugt keinen Codepath, da sie nicht terminiert.
Solche Konstrukte werden stattdessen als \enquote{Codecycle} bezeichnet \cite[vgl.][]{fle.TaxonomyComputationShapes.23}.
Nachdem die Definitionen nun geklärt wurden, kann die Analyse für die Architektur beginnen.

Nach vermutlich notwendigen Initialisierungen, muss die Anwendung beim Starten in einen Codecycle zum Darstellen der \ac{UI} übergehen.
Dieser Codecycle soll fortgehend auch der \enquote{UI-Codecycle} genannt werden, da er sich um das Rendern der \ac{UI} kümmert.

Zu Beginn der Anwendung soll der vorhandene Musikkatalog angezeigt werden.
Da der Katalog permament gespeichert werden soll, muss er in einer oder mehreren Dateien gespeichert werden.
Der Katalog besteht aus einer Liste von Musikstücken.
Jedes Musikstück besteht dabei aus einem Namen sowie den Daten, die zum Abspielen des Stücks benötigt werden (siehe Abschnitt \ref{vorgehenSW-PIDI}). \newline
Zum Darstellen des Katalogs werden dabei nur die Namen der Musikstücke benötigt.
Die weiteren Daten werden erst beim Abspielen der Musik gebraucht.
Entsprechend ist es sinnvoll, die Namen der Musikstücke in einer seperaten Liste (und der Einfachheit halber somit auch einer eigenen Datei) zu speichern.

Um die Startseite der \ac{UI} anzeigen zu können, muss zuerst also zuerst der Katalog vom Dateisystem ausgelesen werden.
Es gibt nun zwei Möglichkeiten zur Anordnung dieses Codepaths zum Auslesen des Katalogs:
\begin{enumerate}
    \item Der Codepath wird vor dem UI-Codecycle ausgeführt
    \item Der Codepath wird parallel zum UI-Codecycle ausgeführt
\end{enumerate}

Der erste Ansatz vereinfacht den Code, der für den UI-Codecycle nötig ist, da davon ausgegangen werden kann, dass der Katalog von Beginn an zur Verfügung steht.
Der zweite Ansatz erlaubt dagegen ein schnelleres Darstellen der \ac{UI}, was die Usability der Anwendung erhöht.
Da die zusätzliche Komplexität hier nicht besonders hoch ist, wurde hier die Usability priorisiert und der zweite Ansatz gewählt.
Solange der Katalog noch nicht geladen wurde, soll dabei eine Lade-Animation statt des Katalogs angezeigt werden.
Daraus folgt auch, dass der UI-Codecycle eine Fallunterscheidung benötigt und darauf basierend etwas anderes darstellt.

Sobald der Katalog geladen wurde, gibt es nun mehrere Möglichkeiten, wie die Nutzer:innen den Zustand der Anwendung ändern können sollen.
\begin{enumerate}
    \item Suchen eines Musikstücks über eine Suchbox
    \item Umbenennen eines Musikstücks über eine zugehörige Eingabebox
    \item Löschen eines Musikstücks über einen zugehörigen Button
    \item Hinzufügen eines Musikstücks durch Klicken auf den \enquote{Import}-Button
    \item Wiedergabe eines Musikstücks über einen zugehörigen Button
\end{enumerate}

Die ersten drei Möglichkeiten benötigen keine neuen Daten.
Stattdessen wird hier nur der Katalog angepasst, bzw. bei der ersten Möglichkeit wird der Katalog nur gefiltert. \newline
Bei allen drei Codepaths stellt sich wieder die Frage, ob sie parallel zum UI-Codecycle ausgeführt werden sollten oder nicht.
Die Parallelisierung bringt jeweils wieder eine erhöhte Komplexität der Implementierung mit sich, stellt aber sicher, dass die \ac{UI} nicht temporär einfriert.
Da die zweite und dritte Aktion eine Interaktion mit dem Dateisystem voraussetzen, was relativ hohe Latenzen mit sich bringen kann, wurde sich entschieden diese parallel zum UI-Codecycle zu gestalten.
Die Suche dagegen soll nicht parallel geschaltet werden.

Für das Hinzufügen eines Musikstücks soll, wie in Abschnitt \ref{vorgehenSW-UI-design} erwähnt, eine zweite Seite dargestellt werden.
Dies benötigt entsprechend eine weitere Fallunterscheidung beim UI-Codecycle.
Nachdem die Nutzer:innen eine Datei zum Hinzufügen gewählt haben, muss diese zum Katalog hinzugefügt werden.
Wie in Abschnitt \ref{vorgehenSW-PIDI} aufgezeigt wird, soll ein eigenes Format zum Abspielen von Musikstücken verwendet werden.
Entsprechend muss es eine Transformation der eingegebenen Daten zum hier verwendeten Format geben.
Je nach Länge des Musikstücks, muss davon ausgegangen werden, dass diese Transformation relativ lange brauchen kann.
Es ist entsprechend sinnvoll, diese Transformation zu machen, bevor das Musikstück in den Katalog eingefügt wird.
Dann kann ein Musikstück aus dem Katalog jederzeit sofort wiedergegeben werden.

Weiterhin ist aus dem selben Grund auch ratsam, diese Transformation parallel zum UI-Codecycle zu gestalten.
Während die Nutzer:innen auf der zweiten Seite sind und den Namen des Musikstücks anpassen können, sollte parallel also der Import der Datei laufen. \newline
Das Ergebnis dieses Codepaths muss das Musikstück im richtigen Datenformat sein.
Diese Daten müssen dann einerseits in einer Datei gespeichert werden und andererseits muss auch der Name des Musikstücks zum Katalog - sowohl in der Datei des Katalogs als auch im bereits verwendeten Speicher dafür - hinzugefügt werden.
Sollten die Nutzer:innen nun aber den Import abbrechen, darf der Katalog noch nicht angepasst sein.
Das heißt, dass dieser Codepath nicht die Anpassung des Katalogs selbst vornehmen sollte.
Stattdessen sollte das im UI-Codecycle getan werden, nachdem die Nutzer:innen den Import abgeschlossen haben und der Codepath erfolgreich fertig gelaufen ist.
Andernfalls sollte das Ergebnis des Codepaths vom UI-Codecycle wieder verworfen werden.

Zuletzt gilt es noch die 5. Interaktion der Nutzer:innen zu betrachten: Die Wiedergabe eines Musikstücks.


% @TODO(Val): SADT Diaram am Ende zeigen


\section{Datenformat für Musikstücke} \label{vorgehenSW-PIDI}

Es gibt bereits viele Datenformate, die zum Speichern von Musikstücken verwendet werden können. Dabei lassen sich solche Formate generell in zwei fundamental verschiedenen Designs unterscheiden.

% @Note(Val): Sollten wir Quellen für die unterschiedlichen Formate hier in den Fußzeilen angeben? Z.B. auf die Standards verweisen?
% @Note(Jay): Wäre glaube ich sinnvoll. Ist es außerdem sinnvoll die Abkürzungen mit aufzunehmen oder reicht es wenn auf die Standards verwiesen wird?
Zum Einen gibt es generelle Audioformate. Dazu gehören solche Formate wie MP3\footnote{formal \enquote{MPEG-1 Audio Layer III} bzw. \enquote{MPEG-2 Audio Layer III}; siehe \cite{iso.MP3} für die Spezifikation des Formats}, WAV\footnote{wird auch \enquote{WAVE}-Format genannt; siehe \cite{kab.WaveFileSpecifications.22} für die Spezifikation des Formats} oder FLAC\footnote{formal \enquote{Free Lossless Audio Codec}; siehe \cite{bw.FLAC.24} für die Spezifikation des Formats}.
Diese Formate speichern für jeden Zeitpunkt des Audios die Information über das Geräusch, das zu diesem Zeitpunkt abzuspielen ist.

Zum Anderen gibt es Formate, die speziell für Musikstücke entwickelt wurden.
Das Vorzeige-Beispiel wäre hier das \ac{MIDI}-Format.
Bei diesen Formaten werden statt Geräusch-Daten Informationen über Noten, die für eine gewisse Zeit zu spielen sind, gespeichert.
Das genaue Geräusch, das am Ende abgespielt werden sollte, wird dabei noch von anderen Faktoren beeinflusst.
So könnten beispielsweise mehrere Noten gleichzeitig zu spielen sein.
Auch könnte das Instrument von Nutzer:innen dynamisch änderbar sein.

Die zweite Art an Formaten ist im Kontext dieses Projekts zu bevorzugen, da es dem Format der Ausgabe näher kommt.
Zum Anspielen eines Klaviers werden nämlich zu jedem Zeitpunkt die Information über derzeit zu spielende Tasten benötigt.
Formate der zweiten Art speichern genau jene Informationen und erfordern damit keine weiteren Informations-Umwandlungen mehr. \newline
Im Gegensatz dazu sind die erstgenannten Formate speziell für digitale Lautsprecher entworfen worden und speichern entsprechend Informationen über die vom Lautsprecher zu spielenden Geräusche.

Wenn hier von Informations-Umwandlung gesprochen wird, meint dies nicht eine simple Datentransformation.
Daten sind eine Enkodierung von Informationen und somit können unterschiedliche Daten die selben Informationen darstellen.
Die Wandlung eines Datensatzes in eine andere Kodierung kan zwar rechenaufwendig werden, ist aber ohne Verlust von Informationen möglich.
Je nach Kontext können Datentransformationen auch ausgelassen oder stark optimiert werden.
Falls grundlegend andere Informationen benötigt werden, ist eine Änderung der Daten nicht nur notwendig, sondern oftmals auch vergleichsweise aufwendig.

Es ist also festzuhalten, dass die Verwendung eines Formats wie \ac{MIDI} hier sinnvoll ist.
Bevor \ac{MIDI} selbst gewählt wird, sollten jedoch noch weitere Aspekte beachtet werden.

Eine Anforderung dieses Projekts ist eine höhere Performanz als die schnellsten menschlichen Pianist:innen zu erreichen (siehe Tabelle \ref{table:anforderungen}).
Entsprechend sollte das gewählte Datenformat der Musikstücke auch möglichst schnell in das Format umgeformt werden können, das für die Ausgabe an die Aktuatoren benötigt wird.
Am performantesten wäre es hierbei, eine Liste jener Daten zu speichern, die zu jedem Zeitpunkt an die Aktuatoren ausgegeben werden müssen, da dann gar keine Datentransformation mehr nötig ist.

Allerdings muss das Datenformat auch möglichst wenig Speicherplatz verbrauchen.
Da der Code auf einem \ac{MC} laufen muss, ist Speicherplatz relativ begrenzt.
Der \ac{MC} muss dabei nicht das gesamte Musikstück auf einmal gespeichert haben, da restliche Teile des Musikstücks auch später von \ac{SAM} nachgereicht werden können.
Das verringert die Wichtigkeit des Speicherplatzes jedoch nur zu Teilen, da ein solches Streamen der Daten mehr Kommunikation zwischen \ac{SAM} und {MC} benötigt.
Da die Latenzen der Kommunikation relativ hoch sein können, gefährdet dies wiederrum das Ziel der Performanz.
% @TODO(Eine Anmerkung wie hoch Latenz & Throughput sein können (oder wo diese Zahlen genannt werden), wäre hier gut)

% @TODO(Val): Quellen für \ac{MIDI} Details einfügen
\ac{MIDI} schneidet hierbei an sich sehr gut ab, da Noten sehr kompakt abgespeichert werden.
Dafür wird eine Enkodierung variabler Länge verwendet.
Da \ac{MIDI} allerdings ein generelles Format ist, das ein Vielzahl von digitalen Instrumenten und Synthesizers unterstützen möchte, beinhält der \ac{MIDI}-Standard eine Vielzahl optionaler Metadaten, die für dieses Projekt irrelevant sind.
Entsprechend würde nur ein Subset des \ac{MIDI}-Standards zum Speichern der Musikdaten in Frage kommen.
Nichtsdestotrotz kann das Format für diesen eingeschränkten Anwendungsfall noch optimiert werden.
Um diese Verbesserungen zu motivieren, soll zuerst die Enodierung von Noten in \ac{MIDI} erläutert werden.

% @Note(Jay): Es könnte interessant sein das zu visualisieren (aslo Noten-sheet zu MIDI)
% @Note(Jay): Wäre eine Tabelle für welche Daten brauchen wie viel Speicher sinnvoll? Wäre übersichtlicher (zusätzlich, nicht stattdessen though, ich mag die Erklärung)
\ac{MIDI} speichert die Notenfolgen in sogenannten \enquote{Nachrichten}.
Nachrichten können auch andere Daten tragen, hier sollen aber nur die Nachrichten zum Spielen von Tönen betrachtet werden.
Jede dieser Nachrichten folgt einer relativen Zeitangabe, im Standard \enquote{delta time} genannt.
\enquote{delta time} gibt an, wie viele Schläge der virtuellen \ac{MIDI}-Uhr zwischen der letzten Nachricht und dieser vergehen sollen.
Die \ac{MIDI}-Uhr kann direkt in Angaben einer Wand-Uhr umgerechnet werden.
Hier ist jedoch wichtig zu bemerken, dass diese \ac{MIDI}-Uhr sehr viel genauer als eine Angabe in Millisekunden ist.
Auch ist zu erwähnen, dass diese \enquote{delta time} eine variable Länge hat, mindestens aber immer ein Byte verwendet.

Nach der \enquote{delta time} folgt dann genau ein Byte für den \enquote{Ereignis-Code} der Nachricht.
Dieser gibt in jeweils 4 Bits den \enquote{Status} und den \enquote{Kanal} des Ereignisses an.
Während der Status angibt, was für eine Aktion ausgeführt werden soll und damit auch wie viele Datenbytes für diese Nachricht noch folgen, besagt der Kanal, für welches Instrument dieses Ereignis gilt.
Wenn die Note gespielt werden soll, folgen darauf noch zwei Bytes, die jeweils die Note und die Anspielstärke abspeichern.
Wenn mit dem Spielen der Note aufgehört werden soll, folgt nur ein Byte, das die jeweilige Note angibt.

Hierbei fallen einige Daten auf, die in diesem Projekt unnötig sind.
So gibt es hier zum Beispiel nur ein einziges Instrument, weswegen die Notwendigkeit unterschiedlicher Kanäle wegfällt.
Auch ist die sehr hohe Auflösung der \enquote{delta time} hier nicht benötigt.
Stattdessen würde eine Auflösung in Millisekunden oder Centisekunden für dieses Projekt ausreichen.

Weiterhin fällt auf, dass für das Spielen jedes Tons in \ac{MIDI} mindestens zwei Nachrichten benötigt werden.
Einmal eine Nachricht zum Starten des Ton-Spielens und einmal eine Nachricht zum Aufhören.
Diese zweite Nachricht wäre nicht nötig, wenn zusammen mit der ersten Nachricht eine Länge, mit der der Ton gespielt werden soll, gespeichert würde.
Diese Speicher-Optimierung bringt allerdings auch Nachteile mit sich.
So verkompliziert es die Transformation der Musikdaten, bevor sie zum Ansteuern der Aktuatoren verwendet werden können.
Auch müssen die zeitlichen Längen, für die die zurzeit spielenden Töne noch zu spielen sind, gespeichert werden.
Dies könnte im Generellen einiges an Speicherplatz verbrauchen.
% @Note(Jay): Können wir bei relativ kurz und relativ wenige bespielhafte Werte nennen? Also wie i.d.R. max 5-10 Magnete gleichzeitig
In diesem speziellen Anwendungsfall lässt sich allerdings annehmen, dass Noten in der Regel nur für relativ kurze Zeiten gespielt werden und dass nur relativ wenige Noten auf einmal gespielt werden.
Da wie in Kapitel \ref{Prototyp} erklärt, auch nur eine geringe Anzahl der Aktuatoren auf einmal aktiviert werden sollen, kann die Menge zusätzlich benötigten Speichers hier sehr gering gehalten werden.

Aufgrund all dieser möglichen Verbesserungen des Formats, wurde sich entschieden, ein eigenes Datenformat für diesen Anwendungsfall zu entwickeln, welches im Folgenden \enquote{\ac{PIDI}} genannt wird.
Abgesehen von einer effizienten Speichernutzung, soll das \ac{PIDI}-Format auch performant zum Ansteuern der Aktuatoren transformiert werden können und möglichst simpel zu benutzen sein.
Außerdem soll es trotz der starken Einschränkung auf diesen Anwendungsfall die Variabilität besitzen, für unterschiedliche Konfigurationen von Klavieren verwendbar zu sein.
Das ist aus dem Grund sinnvoll, dass es die Möglichkeit bietet, die Anzahl verbundener Tasten des Klaviers jederzeit zu verändern.
% @Note(Jay): Wie zum Beispiel eine andere Anzahl an Tasten... es geht sonst nicht klar hervor, was die vorherige Aussage mit den Tests zu tun hat (also eigentlich den Satz der da drunter steht etwas angepasst nach oben ziehen).
Während Testphasen müssen somit nicht alle Tasten des Klaviers über Aktuatoren anspielbar sein.
Auch kann das \ac{PIDI}-Format dann in ähnlichen Projekten mit einer womöglich anderen Anzahl anspielbarer Tasten auf dem Klavier verwendet werden.

Listing \ref{code:PidiCmd struct} zeigt die endgültige Datenstruktur, die für ein individuellen \lstinline{PidiCmd} gewählt wurde, in Form eines C-Bitfields.
Die vollständige Spezifikation des Formats lässt sich in Anhang \ref{appendix-pidi} finden.

\begin{UnbrokenCodePage}[style=CStyle, caption={Definition eines \ac{PIDI}-Kommands}, label={code:PidiCmd struct}]
typedef enum {
    PIANO_KEY_C,
    PIANO_KEY_CS,
    PIANO_KEY_D,
    PIANO_KEY_DS,
    PIANO_KEY_E,
    PIANO_KEY_F,
    PIANO_KEY_FS,
    PIANO_KEY_G,
    PIANO_KEY_GS,
    PIANO_KEY_A,
    PIANO_KEY_AS,
    PIANO_KEY_B,
} PianoKey;

typedef struct PidiCmd {
    uint32_t dt : 12,
    velocity    : 4,
    len         : 8,
    octave      : 4, // needs to be sign-extended when used, because it's a signed 4-Bit integer
    key         : 4;
} PidiCmd;
\end{UnbrokenCodePage}

Ein \lstinline{PidiCmd} stellt dabei das Anspielens eines Tons dar.
Die Töne selbst wurden als ein Paar aus Oktave und Taste in der Oktave dargestellt, da die Anzahl Tasten in einer Oktave auf praktisch allen Klavieren gleich ist.
Die nullte Oktave bezeichnet hierbei die mittlere Oktave des Pianos, während positive und negative Zahlen in Relation zur mittleren Oktave zu verstehen sind.
Mit jeweils 4 Bits können alle 12 Tasten in einer Oktave und alle Oktaven, die auch auf großen Klavieren Platz finden, verwendet werden.

Die \enquote{velocity} eines \lstinline{PidiCmd}s gibt die Anschlagsstärke an.
Um Speicherplatz zu sparen und da genauere Präzision beim Anspielen sich bereits auf Hardware-Seiten als Schwierigkeit ergeben hat (siehe Kapitel \ref{konzeptionHW-ansteuerungskonzept}), wurde sich entschieden, nur 4 Bits für die \enquote{velocity} bereitzustellen.
Zuletzt gibt es dann noch die \lstinline{dt} und \lstinline{len}, die respektiv jeweils die Zeit seit der zuletzt gespielten Note und die Spiellänge der Note darstellen.
Während in \ac{MIDI} eine sehr hohe und dynamisch veränderbare Auflösung für die \enquote{delta time} verwendet wurde, ist \lstinline{dt} hier immer in Millisekunden enkodiert.
Mit den dafür allokierten 12 Bits können $\frac{2^{12}}{1000} = 4,096$ Sekunden ohne Anspielen eines neuen Tons enkodiert werden.
Da die Anspiellänge zusätzlich noch für jeden zurzeit gespielten Ton gespeichert werden muss, wurde entschieden genau 1 Byte dafür zu verwenden.
Dies erlaubt eine leichte und speicher-effiziente Nutzung außerhalb der \lstinline{PidiCmd}-Datenstruktur.
Da 8 Bits nur Spiellängen von bis zu $\frac{2^8}{1000} = 0,256$ Sekunden abspeichern können, wurde entschieden hier stattdessen eine Enkodierung in Centisekunden zu benutzen.
Damit können bis zu $\frac{2^8}{1000} = 2,56$ Sekunden abgespeichert werden.

Insgesamt benötigt ein \lstinline{PidiCmd} dann genau 4 Byte.
Damit passt die Datenstruktur gut in CPU-Register, was eine schnellere Benutzung ermöglicht.
Wenn davon ausgegangen wird, dass die meisten Töne mit einer Anspielstärke gespielt werden und ausklingen bevor sie mit einer anderen oder derselben Stärke wieder gespielt werden, dann benötigt \ac{MIDI} für jeden Ton mindestens 7 Bytes.
Dabei werden 4 Bytes zum initialen Anspielen und 3 Bytes zum Ausklingen des Tons verwendet.
\ac{PIDI} benötigt dagegen immer genau 4 Bytes für jeden Ton.
Damit ist verbraucht \ac{PIDI}-Format mindestens $\frac{7}{4} = 1,75$-Mal weniger Speicher als das \ac{MIDI}-Format.


\section{Logik des Mikrocontrollers} \label{vorgehenSW-MC}

Der \ac{MC} hat grundlegend zwei Aufgaben.
Einerseits muss der \ac{MC} Daten an die Aktuatoren senden, um das Klavier richtig anzuspielen.
Andererseits muss der \ac{MC} auch mit \ac{SAM} kommunizieren können.
Da der \ac{MC} nur einen einzelnen CPU-Kern hat, können diese Aufgaben nur abwechselnd nacheinander und nicht parallel bearebeitet werden.
Während die Anspiellogik in diesem Kapitel erläutert wird, soll die Kommunikation mit \ac{SAM} im nächsten Kapitel \ref{vorgehenSW-SPPP} dargelegt werden.

Um die richtigen Werte zu den Aktuatoren zu senden, müssen nacheinander alle Werte an die Schieberegister gegeben werden.
Der Wert des letzten Schieberegister-Ausgangs muss dabei zuerst gesendet werden, da es dann als erstes komplett durchgeschoben wurde.
Sobald alle Werte ausgesandt wurden, müssen die Ausgänge der Schieberegister gesperrt werden, damit diese nicht ständig fluktuieren.
All das kann beim Arduino, der in Kapitel \ref{Ansteuerung} als \ac{MC} gewählt wurde, über das Ansprechen spezieller \ac{PWM}-Pins getan werden.

Wann immer die Signale für die Aktuatoren ausgesandt werden sollen, müssen diese Werte vorher bereitstehen.
Da 88 Aktuatoren angesteuert werden sollen, muss also eine Liste von 88 \ac{PWM}-Werten befüllt werden.
Im Folgenden soll diese Liste \lstinline{piano} genannt werden.
Um \lstinline{piano} zu befüllen müssen die Informationen des Musikstücks verwendet werden, die wie in Abschnitt \ref{vorgehenSW-PIDI} beschrieben, als eine Liste von \lstinline{PidiCmd}s gespeichert werden.

Die \lstinline{PidiCmd}-Struktur ist nicht nur sehr speichereffizient, sondern erlaubt auch eine performante Anpassung der \lstinline{piano} Liste.
Da die \lstinline{PidiCmd}s zeitlich sortiert sein müssen, reicht ein laufender Index in die Liste.
Um zu entscheiden, ob eine Note gespielt werden soll, wird außerdem die Zeit benötigt, die seit Spielen des letzten \lstinline{PidiCmd}s vergangen ist.
Außerdem muss überprüft werden, ob einige der zurzeit spielenden Töne wieder ausgeschaltet werden sollten.
Um dies schnell berechnen zu können, wird eine Liste mit allen zurzeit gespielten Noten gehalten.
Für jede Note wird dabei die Zeit gespeichert, für die sie noch weiterhin gespielt werden sollte.
Listing \ref{code:Apply PIDICmds} stellt diese Logik in Pseudocode dar.

\begin{UnbrokenCodePage}[style=CStyle, caption={Nutzung der \lstinline{PidiCmd}-Struktur}, label={code:Apply PIDICmds}]
PIDICmds *cmds; // assume this array to be initialized already
u8  piano[88];  // list of values to send to magnets
u32 index = 0;
while (true) {  // Endless Loop of Microcontroller
    u32 start_time   = currentTime(); // time in milliseconds
    u32 elapsed_time = 0;
    update_played_keys(elapsed_time);
    while (index < length(cmds) && cmds[index].dt <= elapsed_time) {
        applyCmd(piano, cmds[index]);
        elapsed_time -= cmds[index].dt;
        add_to_played_keys(cmds[index].dt);
        index++;
    }
    elapsed_time += getElapsedTimeSince(start_time);
}
\end{UnbrokenCodePage}

Die in Listing \ref{code:Apply PIDICmds} erwähnten Funktionen \lstinline{currentTime} und \lstinline{getElapsedTimeSince} sind über die eingebaute Uhr des \ac{MC} umsetzbar.
Die Funktion \lstinline{aplyCmd} setzt die Stärke des Tastenanschlags an der richtigen Stelle in der \lstinline{piano} Liste.
Da die \lstinline{PidiCmd}-Struktur die Anordnung und Anzahl verfügbarer Aktuatoren ignoriert, muss diese Umrechnung von Oktave und Ton in den genauen Aktuator, der diese Taste betätigt, hier geschehen.
Zuletzt verwendet das Listing noch die Funktionen \lstinline{update_played_keys} und \lstinline{add_to_played_keys}.
Diese benötigen eine Liste der zurzeit gespielten Töne.
Weil nur eine bestimmte Anzahl der Aktuatoren zu einem Zeitpunkt aktiv sein dürfen (siehe Kapitel \ref{Prototyp}), kann diese Liste klein gehalten werden.

Sollte ein Musikstück diese Obergrenze zu gleichzeitig zu spielender Noten überschreiten, müssen einige Töne früher beendet werden als eigentlich angesehen.
Hier gibt es mehrere Strategien, die jeweils eigene Vor- und Nachteile mit sich bringen.
Die am leichtesten zu implementierende Idee, würde neue Noten einfach nicht spielen lassen.
Entweder könnten diese neuen Noten übersprungen werden, oder es könnte gewartet werden, bis eine der zurzeit spielenden Noten wieder ausklingen sollen, bevor weitere \lstinline{PidiCmd}s überhaupt betrachtet werden.
Letztere Strategie würde quasi die Geschwindigkeit des Musikstücks kurzzeitig anpassen und eher ungewollte Anpassungen an der Natur des Stücks vornehmen.
Um den Nachteil der ersten Strategie aufzuzeigen, soll ein Beispiel verwendet werden.

Angenommen es dürfen nur 5 Aktuatoren auf einmal aktiviert werden.
Nun werden gerade C, D, E, F und G der mittleren Oktave gespielt.
Das C soll nur noch für ein paar Millisekunden gespielt werden.
Davor soll aber nun ein B gespielt werden.
Dieses B soll nun für eine ganze Sekunde gespielt werden.
Optimal wäre es hier, das C, das sowieso bald ausklingen soll, ein paar Millisekunden früher zu auszuschalten, dami das B zum richtigen Zeitpunkt schon gespielt werden kann.
Die zuerst genannte Strategie würde dagegen das C einfach überhaupt nicht spielen.
% @Note(Jay): Wäre es nicht das B das nicht gespielt wird wenn das C schon an ist?

Aus diesem Beispiel lässt sich eine alternative Strategie entwickeln.
So lassen sich die Längen, für die die bereits gespielten Töne und den neu zu spielenden Ton vergleichen.
Die Töne, die am frühesten wieder ausklingen sollen, können dann bereits ein wenig früher abgebrochen werden.
Da die Liste bereits gespielter Töne kurz sein muss, ist eine Iteration über alle bereits gespielten Töne nicht besonders zeitaufwendig.
Nichtsdestotrotz ist dieses Vorgehen komplizierter und rechenaufwendiger als die beiden erstgenannten Ideen.

Eine weitere Möglichkeit wäre statt der Länge die Anschlagstärken zu vergleichen.
Es kann davon ausgegangen werden, dass das Fehlen stärker zu spielender Töne eher negativ auffallen würde als das Fehlen leiserer Töne.
Es ließe sich auch eine Heuristik erstellen, die sowohl die Anschlagsstärke als auch die noch verbleibende Spiellänge mit einander vermischt.
Ohne Testen an realen Musikstücken, ist es jedoch schwer zu sagen, wie eine solche Heuristik aussehen sollte.
Hier ist es also sinnvoll eine leicht anpassbare Heuristik zu verwenden und während des Testens dann zu analysieren, welche Heuristik die am besten klingende Resultate mit sich bringt.

Die benötigte Logik zum Anspielen des Klaviers ist damit fast vollständig besprochen.
Es fehlt jedoch noch die Logik zum dynamischen Anhalten und Anpassen der Lautstärke und Spielgeschwindigkeit, die in Kapitel \ref{Zielstellung} spezifiziert wurden.

Das Anhalten kann über eine einfachen Bool'schen Wert gelöst werden.
Wenn angehalten wurde, soll statt den Werten aus der \lstinline{piano} Liste, eine Null an jeden Aktuator gesendet werden.
Auch sollen keine weiteren \lstinline{PidiCmd}s angewandt werden.

Die Lautstärke ist über Erhöhen der Anschlagsstärke umsetzbar.
Da \lstinline{PidiCmd}s die Anschlagsstärke in einem abstrakten Wert von 0 bis 15 darstellen, kann dieser Wert über einen Lautstärke-Faktor einfach skaliert werden.

Die Geschwindigkeit kann ebenfalls über einen Faktor implementiert werden.
Dieser Faktor skaliert dabei jedoch die Messung der vergangenen Zeit.
Hierbei ist aufzupassen, dass nicht die in Listing \ref{code:Apply PIDICmds} verwendete Variable \lstinline{elapsed_time} skaliert wird, sondern der Term \lstinline{getElapsedTimeSince}, der zur \lstinline{elapsed_time} hinzu addiert wird.
Ansosten würde nämlich die akkumulierte Zeit der Vergangenheit angepasst werden, statt die Geschwindigkeit der zurzeit laufenden Zeit zu verändern.


\section{Kommunikation} \label{vorgehenSW-SPPP}

Den in Kapitel \ref{Zielstellung} gestellten Anforderungen nach, soll über \ac{SAM} das automatisch gespielte Musikstück dynamisch wählbar sein.
Das bringt mit sich, dass \ac{SAM} Daten an den \ac{MC} senden können muss.
Abgesehen von den zu spielenden Noten, muss \ac{SAM} dem \ac{MC} auch mitteilen können, ob angehalten, oder Lautstärke und Geschwindigkeit angepasst werden sollen.

% @TODO(Val): Source for why these questions in particular maybe
Hierbei sollten mehrere Fragen aufkommen:
\begin{enumerate}
    \item Geht die Kommunikation in beide Richtungen oder nur von \ac{SAM} zum \ac{MC}?
    \item Welche Medien sollen für die Kommunikation unterstüzt werden?
    \item Soll die Kommunikation seriell oder parallel ablaufen?
    \item Über welches Protokoll werden die Daten enkodiert?
    \item Soll die Kommunikation synchron, asynchron oder isochron ablaufen?
    \item Wie wird Datenkonsistenz sichergestellt?
    \item Wie wird Datenvollständigkeit sichergestellt?
    \item Wie wird mit Fehlern umgegangen?
\end{enumerate}

Zuerst mag eine einseitige Kommunikation ausreichend erscheinen.
Allerdings erlaubt eine zweiseitige Kommunikation bessere Portabilität der Anwendung.
So muss \ac{SAM} wissen, über welchen Port der \ac{MC} angesprochen werden kann.
Da nicht alle Maschinen die gleichen Ports zur Verfügung stehen haben, sollte dieser Port dynamisch wählbar sein.
Um den korrekten Port entsprechend auch dynamisch finden zu können, muss der \ac{MC} ein einzigartiges Signal über den Port zu \ac{SAM} schicken können.
Hier kann beispielsweise ein spezielles \enquote{PING}-Signal über jeden verfügbaren Port geschickt werden.
Während der \enquote{PING} von anderen Ports ignoriert wird, kann der \ac{MC} mit dem entsprechenden \enquote{PONG}-Signal antworten.
Somit kann \ac{SAM} jederzeit die Verfügbarkeit des \ac{MC}s und dessen Port prüfen.

Mögliche Übertragungsmedien für die Kommunikation lassen sich in die Kategorien \enquote{Kabel} und \enquote{Kabellos} einteilen.
Kabellose Medien wie WLAN oder Bluetooth benötigen bei dem in Kapitel \ref{Ansteuerung} gewählten \ac{MC} ein weiteres Modul.
Das würde die Kosten weiter erhöhen und damit entgegen dem Ziel einer möglichst preisgünstigen Entwicklung sprechen.
Nichtsdestotrotz sollte die Kommunikation erweiterbar konzipiert werden, um auch leicht kabellos umgesetzt werden zu können.
Da es im gewählten \ac{MC} jedoch schon eingebaut ist und damit die preisgünstigste Möglichkeit darstellt, soll hier eine Verbindung über ein USB-Kabel zwischen \ac{MC} und \ac{SAM} angenommen werden.

Damit wird auch die nächste Frage bereits beantwortet, da über das USB-Kabel nur eine serielle Kommunikation möglich ist.
Der gewählte \ac{MC} schränkt auch die möglichen Protokolle zur Übertragung von Daten ein.
So unterstützt der Arduino Uno R3 nur die folgenden drei Übertragungsprotokolle:
\begin{enumerate}
    \item \ac{I2C}
    \item \ac{SPC}
    \item \ac{UART}
\end{enumerate}
\ac{I2C} und \ac{SPC} sind beides Protokolle, die für die Kommunikation mit Periphergeräten gedacht wurden.
\ac{UART} wird dagegen von Arduino Dokumentation für generelle Kommunikation mit einem PC empfohlen. % @TODO(Val): Source - Documentation/Examples
Da die Desktop-Anwendung das selbe Protokoll sprechen können muss, ist die Nutzung von \ac{UART} auch insoweit sinnvoll, dass Windows nativ die Nutzung des \ac{UART}-Protokolls über sogenannte \enquote{COM}-Ports ermöglicht.
Da \ac{UART} verwendet wird, steht auch fest, dass die Übertragung von Daten asynchron abläuft.

% @Note(Val): Sollte erwähnt werden, dass UI & MC die selbe Baud-Rate, Daten-Bit-Siue, etc. haben müssen?
% Siehe List hier: https://en.wikipedia.org/wiki/Universal_asynchronous_receiver-transmitter#Transmitting_and_receiving_serial_data
Das \ac{UART}-Protokoll bringt auf Level der Bit-Übertragung bereits Mechanismen zum Sicherstellen der Datenkonsistenz und Vollständigkeit mit sich. % @Note(Val): Mention what mechanisms these are maybe
Bis jetzt wurde jedoch nur geklärt wie die Bits der Nachrichten übertragen werden, nicht jedoch wie diese Nachrichten aussehen sollen.
Das benötigt ein weiteres Protokoll, das diesmal jedoch über Software in den Anwendungen des Arduinos und Desktops implementiert werden muss.
Im Folgenden soll dieses Protokoll \enquote{\ac{SPPP}} genannt werden.

Es wäre hierbei möglich ein bereits existierendes, generelles Kommunikationsprotokoll zu verwenden.
Zum Beispiel könnten die Daten über das \ac{HTTP} gesendet werden.
Jedoch muss selbst dann noch ein spezielles Schema spezifiziert werden, in dem die Daten angeordnet werden.
Entsprechend ist es sinnvoll hier ein eigenes, einfaches Protokoll zu entwerfen, dass alle Anforderungen an die Kommunikation abdecken kann.
Dabei muss das \ac{SPPP} die folgenden Anforderungen erfüllen, welche basierend auf den in Kapitel \ref{Zielstellung} gestellten Anforderungen abgeleitet wurden.

\begin{enumerate}
    \item \ac{SAM} muss einen \enquote{Ping} senden können, auf die der \ac{MC} mit einem \enquote{Pong} antwortet, damit der genaue Port, an dem der Arduino ist, identifiziert werden kann.
    \item \ac{SAM} muss dem \ac{MC} sagen können, dass die Musik angehalten oder fortgesetzt werden soll
    \item Die Lautstärke muss von \ac{SAM} an den \ac{MC} gesendet werden können
    \item Die Geschwindigkeit muss von \ac{SAM} an den \ac{MC} gesendet werden können
    \item Musikdaten in Form von \lstinline|PidiCmd|s muss von \ac{SAM} an den \ac{MC} gesendet werden können
    \item \ac{SAM} muss dem \ac{MC} sagen können, dass zu einem beliebigen Zeitpunkt im Musikstück gesprungen werden soll
    \item Fehler in der Kommunikation sollten erkannt werden, damit \ac{SAM} und \ac{MC} diese entsprechen behandeln können
    \item Die Latenz beim Senden von Nachrichten sollte möglichst gering und mindestens unter einer Sekunde sein
    \item Das Protokoll soll erweiterbar sein, sodass leicht weitere Versionen erstellt werden können, ohne Backwards-Compatibility zu brechen
\end{enumerate}

Aus den Anforderungen wird klar, dass es unterschiedliche Arten an Nachrichten gibt, die vom Protokoll unterstützt werden müssen.
Ein entsprechend simpler Aufbau von \ac{SPPP} Nachrichten besteht aus einer ID, die den Typ der Nachricht identifiziert, und einem Datensatz, der je nach Nachrichten-Typ unterschiedlich spezifiziert ist.
Damit lässt sich das Protokoll auch leicht erweitern, da neue Nachrichten-Typen einfach hinzugefügt werden können.
Es empfiehlt sich außerdem jede Nachricht mit bestimmten \enquote{Magic Bytes} zu starten, um keine arbiträren Datenströme als Nachrichten zu interpretieren.

Um die Latenz der Nachrichten unabhängig technischer Gegebenheiten gering zu halten, empfiehlt es sich, die Anzahl zu übertragener Bytes möglichst gering zu halten.
Entsprechend wurde entschieden, die IDs der Nachrichten-Typen auf jeweils ein einzelnes Byte zu reduzieren.
Zur leichteren Identifizierung werden in Nachrichten-IDs nur ASCII-enkodierte Buchstaben verwendet.
Weiterhin wird hier die Konvention eingeführt, dass Großbuchstaben eine Nachricht von \ac{SAM} und Kleinbuchstaben eine Nachricht des \ac{MC}s spezifzieren.

Die Magic Bytes des Protokolls werden als die 3-Byte Sequenz \enquote{SPP} definiert.
Ein einzelnes Byte wäre zu unsicher, da jedes zufällig empfangene Byte eine $\frac{1}{256} = 0,39\%$ Chance hat das Magic Byte zu sein.

Die meisten Nachrichten müssen jeweils nur eine einzelne Zahl übersenden.
Tabelle \ref{table:SPPP-Messages} listet alle Nachrichtentypen mit ihren jeweils zu übertragenen Daten auf.
Die vollständige Spezifikation des Protokolls findet sich in Anhang \ref{appendix-sppp}.

\begin{table}[htbp]
    \centering
    \begin{tabular}{|p{6mm}|p{80mm}|p{55mm}|}
        \theadstart{ID} & \theadcol{Beschreibung} & \theadcol{Payload} \\ \hline
        \enquote{P} & \enquote{Ping}-Nachricht & - \\ \hline
        \enquote{p} & \enquote{Pong}-Nachricht - Antwort vom \ac{MC} auf Ping-Nachricht & Maximal-Anzahl von \lstinline|PidiCmd|s pro \enquote{Music}-Nachricht als 16-Bit Zahl \\ \hline
        \enquote{C} & \enquote{Continue}-Nachricht, zum Anhalten bzw. Fortsetzen der Musik & 1 Byte; Nur bei 0 soll die Musik angehalten werden \\ \hline
        \enquote{V} & \enquote{Volume}-Nachricht - setzt die Lautstärke & 32-bit Floating-Point Wert \\ \hline
        \enquote{S} & \enquote{Speed}-Nachricht - setzt die Abspielgeschwindigkeit & 32-bit Floating-Point Wert \\ \hline
        \enquote{s} & \enquote{Success}-Nachricht - Antwort vom \ac{MC} auf jede erfolgreich erhaltene Nachricht & - \\ \hline
        \enquote{M} & \enquote{Music}-Nachricht & siehe Abschnitt \ref{SPPP-Pidi-Messages} \\ \hline
        \enquote{N} & \enquote{New-Music}-Nachricht & siehe Abschnitt \ref{SPPP-Pidi-Messages} \\ \hline
        \enquote{r} & \enquote{Request}-Nachricht - vom \ac{MC} geschickt (siehe Abschnitt \ref{SPPP-Pidi-Messages}) & - \\ \hline
    \end{tabular}
    \caption{\ac{SPPP}-Nachrichten}
    \label{table:SPPP-Messages}
\end{table}

\subsection{Fehlerbehandlung} \label{SPPP-Error-Handling}

% @Note(Val): Einleitung hier redet von 'Erkennung' der Fehler, Subsection-Titel ist aber 'Fehlerbehandlung' - da sollte eins von beiden wahrscheinlich gefixt werden
Wie in den oben gelisteten Anforderungen erwähnt, benötigt es jedoch noch eine Möglichkeit Fehler in der Kommunikation zu erkennen.
Es gibt hierbei grundsätzlich drei Arten an potenziellen Fehlern:

\begin{enumerate}
    \item Inkorrekte Daten werden empfangen
    \item Die Nachricht wird nicht empfangen
    \item Teile der Nachricht werden nicht empfangen
\end{enumerate}

Die erste Art an Fehlern soll hier erstmal ignoriert werden, da sie dank der von USB und \ac{UART} versicherten Datenkonsitenz ein relativ geringes Eintrittsrisiko darstellt.
Nichtsdestotrotz ist dies eine mögliche Fehlerquelle, die in Erweiterungen an diese Arbeit ausgebessert werden sollte.
Eine mögliche Sicherstellung der Datenkonsistenz würde beispielsweise über das Mitsenden eines Kontroll-Bytes funktionieren.

Der zweite Fehler kann sowohl durch Fehler in der Übertragung, als auch durch ein Fehler bei der Software des Empfängers entstehen.
Eine einfache Lösung dieses Problems, lässt den Empfänger eine Empfangsbestätigung zurücksenden.
Das selbe Prinzip wird bei der oben erwänten \enquote{Ping} und \enquote{Pong}-Nachricht verwendet.
Ein mögliches Problem beim Senden einer Empfangsbestätigung ist die Ungewissheit, ob die Empfangsbestätigung selbst empfangen wurde.
Dann müsste nämlich eine Empfangsbestätigung für die Empfangsbestätigung gesendet werden, welche ebenfalls wieder als empfangen bestätigt werden müsste, bis nur noch Empfangsbestätigungen hin und her geschickt werden.

Es stellt sich jedoch heraus, dass das hier kein Problem ist.
Sollte eine Empfangsbestätigung nicht empfangen werden, muss der Sender die selbe Nachricht nochmal senden.
Solange das zweimalig Erhalten der selben Nachricht genau die selben Auswirkungen hat wie das einmalige Erhalten der Nachricht, wird keine Empfangsbestätigung für die Empfangsbestätigung selbst benötigt, da die Nachricht ohne Risiken einfach nochmal geschickt werden kann.
Wenn die in Tabelle \ref{table:SPPP-Messages} gelisteten Nachrichtentypen betrachtet werden, fällt außerdem auf, dass nur die Nachrichten, die von \ac{SAM} gesendet werden, eine Empfangsbestätigung benötigen.
Diese Bestätigung soll über die \enquote{Success}-Nachricht gegeben werden, welche entsprechend nur vom \ac{MC} geschickt werden muss.

Ein weiteres Problem, das mit Empfangsbestätigungen auftreten kann, ist das Zuordnen der Nachricht, die nun als empfangen bestätigt wurde.
Sollte \ac{SAM} beispielsweise zwei Nachrichten direkt nacheinander schicken und dann nur eine einzelne \enquote{Success}-Nachricht zurück erhalten, ist unklar welche der beiden Nachrichten nun angekommen ist und welche nicht.
Dies kann gelöst werden, indem jeder Nachricht eine einzigartige Nummer zugeordnet wird und die \enquote{Success}-Nachricht diese Nummer referenziert.

Alternativ kann auch spezifziert werden, dass eine neue Nachricht nur gesendet werden darf, wenn eine \enquote{Success}-Nachricht erhalten wurde oder eine gewisse Zeit vergangen ist.
Diese Zeit wird auch als \enquote{Timeout} benannt.
Die zweite Methode bringt mit sich, dass das \ac{SPPP} Protokoll synchron wird und deshalb weniger flexibel als die asynchrone, erste Lösungsvariante erscheinen mag.
Allerdings erleichtert die Synchronisierung des Protokolls auch den Umgang mit dem 3. Fehler, wie nachher gezeigt wird.
Entsprechend wird sich für diese Lösungsmöglichkeit entschieden.

Weiterhin sollte die Frage aufkommen, warum statt einer eigenen \enquote{Pong}-Nachricht nicht einfach die selbe \enquote{Success}-Nachrich gesendet werden kann, wenn der Austausch von \enquote{Ping}- und \enquote{Pong}-Nachrichten genauso dem Prinzip der Empfangsbestätigung folgt.
Der Grund dafür liegt in den \enquote{Music}-Nachrichten, die eine variable Länge haben.
Da dieses Protokoll - wie auch das in Kapitel \ref{vorgehenSW-PIDI} spezifzierte \ac{PIDI}-Format - portabel für verschiedene Hardware-Voraussetzungen sein soll, kann \ac{SAM} nicht die Speicherkapazitäten des \ac{MC}s voraussetzen.
Entsprechend muss der \ac{MC} \ac{SAM} irgendwie mitteilen, was die akzeptierte Maximallänge für die \enquote{Music}-Nachricht ist.
Da die \enquote{Ping}-Nachricht im Regelfall sowieso die zuerst gesendete Nachricht wäre, kann der \ac{MC} deren Empfangsbestätigung nutzen, um \ac{SAM} dieses Maximum mitzuteilen.
Damit ist die \enquote{Ping}-Nachricht nun notwendigerweise die zuerst gesendete Nachricht in diesem Protokoll.

Es bleibt nun noch der 3. Fehler zu behandeln.
Wenn ein Teil der gesendeten Nachricht ausfällt, gibt es zwei Möglichkeiten:
Entweder werden weitere Bytes empfangen, sodass eine scheinbar vollständige, wenn auch inkorrekte Nachricht erhalten wird.
Das ist im Endeffekt wieder das 1. Problem und wird ebenso im Rahmen dieser Arbeit ignoriert.
Weitere Versionen des Protokolls sollten diese Quellen möglicher Dateninkonsistenz jedoch behandeln.
Es ist allerdings auch möglich, dass keine weiteren Bytes empfangen werden und die Nachricht unvollständig bleibt.
Da das Protokoll synchron ist und keine weiteren Nachrichten gesendet werden sollten, bevor Empfangsbestätigung zurückgeschickt wurde, ist dies tatsächlich der sehr viel wahrscheinlichere Fall.
Da für die Behandlung des 2. Problems sowieso schon ein Timeout festgelegt werden muss, kann dieser Timeout hier ebenfalls verwendet werden.
Sobald der Timeout abgelaufen ist und die Nachricht noch nicht vollständig empfangen wurde, soll diese einfach verworfen werden.
Sollten die fehlenden Bytes nach Ablauf des Timeouts eintreffen, werden diese ignoriert, da sie sehr wahrscheinlich nicht mit den Magic-Bytes des \ac{SPPP} Protokolls beginnen.

In den oben genannten Anforderungen wurde die maximale Latenz für Nachrichten auf 1 Sekunde gesetzt.
Diese Anforderung kann eins-zu-eins als Wert des Timeouts von \ac{SPPP}-Nachrichten übernommen werden.
\ac{SAM} muss dabei jedoch den doppelten \ac{Timeout} als Wert nehmen, da sie zusätzlich noch auf den Eingang der Empfangsbestätigung warten muss.

\subsection{\enquote{Music}-Nachrichten} \label{SPPP-Pidi-Messages}

Die grundlegende Aufgabe, für die die Kommunikation zwischen \ac{SAM} und \ac{MC} benötigt wird, ist das Transferieren der zu spielenden Musikdaten.
Wie in Kapitel \ref{vorgehenSW-MC} beschrieben, verwendet der \ac{MC} das selbst-erstellte \ac{PIDI}-Format zum Speichern der Musikdaten.
Entsprechend ist es sinnvoll, diese Daten direkt im gleichen Format an den \ac{MC} zu schicken.

Da der Speicherplatz des \ac{MC}s jedoch vergleichsweise stark begrenzt ist, können viele Songs nicht komplett gespeichert werden.
Auch wenn diese Limitation mit Erweiterungen der Hardware gelöst werden könnten, würden diese die Kosten weiter heben.
Um dem Ziel der Arbeit gerecht zu werden, darf kein großer Speicherplatz vorausgesetzt werden.
Wenn also nicht davon auszugehen ist, dass das gesamte Musikstück auf einmal auf dem \ac{MC} gespeichert werden kann, müssen die Musikdaten in Teilen nach einander geschickt werden.
In anderen Worten: es ist ein Streaming der Musikdaten notwendig.

Eine erste Problematik, die hierbei aufkommt ist die Latenz der Nachrichten.
Wenn nach Spielen eines Teils des Songs immer eine längere Wartezeit folgt, bevor die nächsten Töne gespielt werden können, macht es das selbst-spielende Klavier praktisch unnutzbar.
Diese Problematik ist auch als \enquote{Buffering} bekannt. % @TODO(Val): Source for Buffering
Die einfachste Art dem Vorzeubugen ist durch die Verwendung von zwei Buffern für die \lstinline|PidiCmd|s.
Ein Buffer hält die derzeit zu spielenden \lstinline|PidiCmd|s, während der zweite Buffer mit den danach zu spielenden \lstinline|PidiCmd|s befüllt werden kann.
Sobald der erste Buffer fertig gespielt wurde, können die beiden Buffer effizient mit einem Tausch ihrer Pointer gewechselt werden.

Das Problem des Bufferings kann dann nur noch vorkommen, wenn der erste Buffer fertig gespielt wurde, bevor der nächste Buffer aufgefüllt werden konnte.
Eine einfache Verbesserung dieser Strategie ist die Nutzung von mehr als nur zwei Buffern.
Wenn zum Beispiel drei Buffer genutzt werden, müssen zwei Buffer durchgespielt werden, bevor der nächste Buffer aufgefüllt werden muss.
Auch können die Buffer bereits getauscht werden, bevor die Nachricht fertig gelesen wurde, solange zumindest ein \lstinline|PidiCmd| bereits gelesen wurde.

Die nächste Schwierigkeit kommt daher, dass \ac{SAM} wissen muss, wann der nächste Teil des Musikstücks benötigt wird.
\ac{SAM} könnte versuchen selbst die vergangene Zeit zu zählen und die selben Berechnung wie der \ac{MC} machen, um zu wissen, wieweit der \ac{MC} bis jetzt gespielt hat.
Falls hierbei jedoch ein Fehler auftritt, würden die Musikdaten zum falschen Zeitpunkt gesendet werden.
Abgesehen davon wäre dies auch ein relativ großer Entwicklungsaufwand.
Einfacher ist es, wenn der \ac{MC} eine bestimmte Nachricht schickt, um den nächsten Teil des Musikstücks anzufordern.
In Tabelle \ref{table:SPPP-Messages} ist diese Nachricht als \enquote{Request}-Nachricht spezifiziert.

Die \enquote{Request}-Nachricht ist die einzige Nachricht, die der \ac{MC} schickt, ohne auf eine Nachricht von \ac{SAM} zu antworten.
Trotzdem muss \ac{SAM} hier nicht mit einer Empfangsbestätigung antworten, da sie sowieso mit einer Nachricht antwortet.
Nur ist die Antwort von \ac{SAM} eine \enquote{Music}-Nachricht stattdessen.

Die \enquote{Request}-Nachricht enthält, wie in Tabelle \ref{table:SPPP-Messages} spezifiziert, keine weiteren Daten.
Das heißt, dass \ac{SAM} sich merken muss wie weit im Musikstück die letzte Nachricht fortgeschritten war.
Ein alternativer Ansatz würde den \ac{MC} speichern lassen, wie viele \lstinline{PidiCmd}s bereits gespielt wurden und würde diesen Index in der \enquote{Request}-Nachricht an \ac{SAM} schicken.
Beide Methoden geben sich nicht besonders viel, hier wurde sich jedoch für die erste Möglichkeit entschieden, da sie der Desktop-Anwendung mehr Flexibilität bietet und weniger Daten übertragen werden müssen.

Die soweit beschriebene Strategie funktioniert zum Spielen vollständiger Stücke nacheinander.
Nun soll die Anwendung aber auch die Möglichkeit bieten, während des Spielen eines Stückes zu einem anderen zu wechseln.
In diesem Fall muss dem \ac{MC} mitgeteilt werden, dass ein neues Stück anfängt und alle Aktuatoren zu Beginn wieder ausgeschaltet werden sollen.

Zusätzlich soll es den Nutzer:innen möglich sein, in einem zurzeit spielenden Stück zu einem anderem Zeitpunkt zu springen.
In diesem Fall müssen die zurzeit aktiven Aktuatoren womöglich ebenfalls ausgeschaltet werden.
% @Note(Jay): Es ist etwas unverständlich warum
Jedoch ist es hier im Allgemeinen nicht der Fall, dass alle Aktuatoren ausgeschaltet werden sollten.
Die Aktuatoren der Noten, die bis zu dem gewählten Zeitpunkt gespielt werden sollen, müssen nämlich angeschaltet werden.
In Kapitel \ref{vorgehenSW-MC} wurde beschrieben, wie der \ac{MC} eine Liste bereits gespielter Noten für die selbe Problematik verwendet.
Es liegt entsprechend nahe, das selbe Konzept hier zu verwenden.
So kann ebenjene Liste direkt auf Seiten \ac{SAM}s erstellt werden und zum \ac{MC} geschickt werden.

Es müssen hier jedoch noch die Elemente innerhalb dieser Liste spezifiziert werden.
Im Folgenden sollen diese Elemente als \lstinline|PlayedKey|s bezeichnet werden.
Wie in Listing \ref{code:Apply PIDICmds} auch, müssen die \lstinline|PlayedKey|s die verbleibende Länge, mit der der Ton gespielt werden soll, speichern.
Weiterhin muss auch die Stärke, mit der der Ton gespielt werden soll, gespeichert werden.
Die \lstinline|PlayedKey|-Struktur besteht entsprechend aus einer Referenz auf den Ton, der Länge und Spielstärke.
Wie im \ac{PIDI}-Format wird die anzuspielende Taste über Oktave und Note definiert.
Da Oktave, Note und Anspielstärke im \ac{PIDI}-Format jeweils als 4-Bit Zahlen und die Länge als 8-Bit Zahl spezifziert wurde, benötigt eine \lstinline|PlayedKey|-Struktur 20 Bits.
Das heißt auch, dass 3 Byte für die Struktur benötigt werden, wobei 4 Bits als Padding verwendet werden.

Auf Seiten des \ac{MC}s ergibt es Sinn die Oktave und Note direkt in den Index für den zuständigen Aktuator zu transformieren, damit diese Berechnung nur einmal ausgeführt werden muss.
Ein weiterer Unterschied zwischen der \lstinline|PlayedKey|s Liste in der \enquote{Music}-Nachricht und auf dem \ac{MC} ist in der Länge der Liste.
Da der \ac{MC} nur eine bestimmte Anzahl gleichzeitig spielender Tasten haben darf, ist die Länge dessen Liste beschränkt.
Da das \ac{SPPP} Protokoll ebenjene Feinheiten der Hardware abstrahieren soll, ist diese Limitierung in der \enquote{Music}-Nachricht nicht gegeben.
Sollten in der Nachricht also mehr \lstinline|PlayedKey|s sein, als der \ac{MC} gleichzeitig spielen darf, muss der \ac{MC} das gleiche Verfahren zum Eliminieren einiger \lstinline|PlayedKey|s anwenden, dass er auch sonst verwendet (siehe Kapitel \ref{vorgehenSW-MC}).

Da diese Liste nur übersendet werden muss, wenn ein neues Musikstück angefangen wird, oder zu einer anderen Stelle im spielende Stück gesprungen wird, gibt es zwei Möglichkeiten.
Entweder wird ein Byte in der \enquote{Music}-Nachricht eingefügt, dass klarstellt, ob die Liste von \lstinline|PlayedKey|s vorhanden ist oder nicht.
Oder es wird ein anderer Nachrichten-Typ dafür verwendet.
Letztere Strategie benötigt kein zusätzliches Byte in der Nachricht und wurde somit gewählt.
Dafür wird nun die \enquote{New-Music}-Nachricht verwendet.
Beim Eingang einer \enquote{New-Music}-Nachricht - anders als bei einer \enquote{Music}-Nachricht - ist es nicht erwünscht die zuvor eingegangenen \lstinline|PidiCmd|s noch fertig zu spielen.

Zuletzt mag noch die Frage aufkommen, was passieren soll, wenn das Musikstück fertig gespielt wurde.
Sollte es dafür ebenfalls einen eigenen Nachrichtentyp geben?
Das wäre eine simple Lösung, würde das Protokoll aber ein wenig verkomplizieren.
Sollte \ac{SAM} stattdessen die eingehenden \enquote{Request}-Nachrichten einfach ignorieren?
Dann würde der \ac{MC} endlos neue \enquote{Request}-Nachrichten schicken und somit unnötige Arbeit auf sich nehmen.
Stattdessen wurde entschieden, am Ende des Musikstücks eine \enquote{Music}-Nachricht mit einer leeren Liste von \lstinline|PidiCmd|s zu schicken.
Damit wid das \ac{SPPP} Protokoll nicht unnötig erweitert und der \ac{MC} muss nicht endlos neue Nachrichten schicken.
Der \ac{MC} sollte keine weiteren \enquote{Request}-Nachrichten schicken, sobald beide Buffer von \lstinline|PidiCmd|s leer sind.
Auf den ersten Blick mag das nach weiterer Arbeit klingen, diese Logik sollte allerdings zu Start des \ac{MC}s - bevor das erste Musikstück gespielt wurde - sowieso gelten.
Entsprechend ist es kein weiterer Aufwand in der Ausführung oder Entwicklung des \ac{MC}s.

