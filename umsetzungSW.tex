%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Autoren des Abschnitts:
%   Val Richter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% !TEX root =  master.tex
\chapter{Umsetzung - Software} \label{umsetzungSW}
\chapterauthor{Val Richter}

\nocite{*}
% - Probleme, Schwierigkeiten, Änderungen während der Umsetzung \newline
% - vllt. kurze Code-Schnippsel von besonders interessanten Teilen

Es steht nun ein Konzept für die benötigten Datenstrukturen und das erwünschte Verhalten der Software-Komponenten.
Dieses Verhalten kann nun jedoch auf unterschiedliche Arten entwickelt werden.
Ein möglicher Ansatz für die Entwicklung sieht zum Beispiel initial eine Klassifizierung aller logischen Objekte zur Laufzeit des gewünschten Programms vor.
Daraufhin kann dann analysiert werden, wie diese Objekte miteinander kommunizieren müssen und welche Daten diese haben und teilen müssen, um das erwünschte Verhalten der Software zu bekommen.
Im Folgenden soll diese Entwicklungs-Strategie als \enquote{Top-Down}-Ansatz bezeichnet werden.
Ein Top-Down-Ansatz klingt verlockend, da es scheint, als würde damit direkt die erwünschte Software geschrieben werden können.
Oftmals scheitert dieses Vorgehen jedoch in der Praxis. % @TODO(Val): Quelle & (belegte) Gründe warum es scheitert

Ein alternativer, \enquote{Bottom-Up}-Ansatz ist der von Casey Muratori als \enquote{Semantic Compression} \cite{mur.SemanticCompression.14} Getaufte.
Statt das Programm basierend auf logischen Objekten zu teilen, wird hier stattdessen eine Teilung in Schritte des gewünschten Verhaltens vorgenommen.
Weiterhin ist diese Teilung iterativ und geschieht während der Entwicklung, statt als seperate Aufgabe davor - wie es im davor beschriebenen Top-Down-Ansatz der Fall ist.
Sobald ein Teil des erwünschten Verhaltens konkret definiert wurde, kann dies in der einfachsten Art entwickelt werden.
Hierbei werden Gedanken der Wartbarkeit erstmal ignoriert.
Auch werden Abstraktionen in diesem Schritt noch nicht fortgeführt.
Stattdessen wird hier nur betrachtet, ob das erwünschte Teilverhalten funktional richtig implementiert wurden.

Bevor nun jedoch der nächste Teil der Anwendung implementiert wird, kommt die Semantische Kompression.
Auf lang oder kurz wird es vorkommen, dass zwei Teile des Codes die selbe oder eine ähnliche Folge von Operationen durchlaufen.
Diesem Ansatz nach wird nun der Code nach solchen semantischen Duplikaten durchsucht.
Solche Duplikate können dann extrahiert werden und in einzelnen Funktionen oder Datenstrukturen komprimiert werden.
Diese Komprimierung ist dabei nicht unbedingt eine syntaktische Komprimierung sondern eine semantische \cite[vgl. ]{mur.SemanticCompression.14}.

Beide Strategien zielen am Ende auf Code mit den gleichen Attributen ab.
Der Code soll gut lesbar, wartbar und erweiterbar sein.
Der erste Ansatz nimmt dabei an, dass die Teilung in logische Objekte das Verständnis der Codebasis erleichtert.
Der Bottom-Up Ansatz streitet diese Annahme im Generellen ab und behauptet stattdessen, dass semantisch komprimierter Code besser lesbar und verständlich ist, da es keine unnötigen Abstraktionen gibt und die existierenden Abstraktionen noch so nah an der konkreten Aufgabe sind wie nötig.
Ähnlich argumentieren beide Strategien, dass sie jeweils höhere Wartbarkeit und Erweiterbarkeit liefern.
Der fundamentale Gegensatz der beiden Ansätze kann jedoch - wie an dem einen Beispiel hoffentlich sichtbar wurde - in ihrer Haltung gegenüber Abstraktion finden.

Im Top-Down Ansatz wird Abstraktion generell positiv betrachtet.
Die Entwicklung beginnt mit einer abstrakten Klassifikation vermutlich benötigter Objekte und seperiert die Entwicklung entlang dieser Objekte.
Eine falsch gewählte Struktur oder Abstraktion dieser Objekte kann die Entwicklung entsprechend stark erschweren.
Der Bottom-Up Ansatz steht Abstraktion dagegen kritisch gegenüber.
Abstraktion ist hier immer noch erwünscht, aber nur wenn die Abstraktion die Reduzierung logischer Duplizierungen mit sich bringt und nur genau so weit abstrahiert ist wie nötig.
Unnötige Abstraktion oder Abstraktion, die auf einem höheren Level als nötig für das zu lösende Problem ist, ist hier negativ konnotiert.
Weiterhin wird hier nicht angenommen, dass zu Beginn der Entwicklung genug Wissen und Expertise besteht, um eine sinnvolle Architektur für den Code finden zu können.
Stattdessen ist die Semantische Kompression ein Verfahren zum explorativen Finden einer solchen sinnvollen Architektur.
In der Implementierung dieses Projekts wurde der Ansatz der Semantic Compression verwendet, da Erfahrungen mit besser und schlechter strukturierter Software dessen Thesen eher unterstützen.

Neben dem Entwicklungsansatz gibt es noch andere Entscheidungen, die die gesamte Entwicklung beeinflussen.
So ist auch die Wahl der Programmiersprache eine substantive und weitreichende Entscheidung.
Hier wurde sich entschieden, die gesamte Implementierung in der Programmiersprache C\footnote{Streng genommen ist hier der ISO-Standard C99 gemeint \cite*[siehe ][]{iso.c99}. Der Einfachheit halber wird in dieser Arbeit jedoch nur von \enquote{C} gesprochen.} zu erstellen.
Da der \ac{MC} vergleichsweise nur sehr begrenzten Speicherplatz zur Verfügung hat, ist die manuelle Speicherverwaltung von C hier sehr wünschenswert.

Aber auch für die Entwicklung der \ac{UI}, wo der verfügbare Speicherplatz praktisch nicht begrenzt ist, wurde sich entschieden C zu verwenden.
Der hauptsächliche Grund dafür ist die Transparenz der Sprache.
Während viele Nachfolger von C versuchen ihre Semantik abstrakt halten, um die eigentliche Implementierung davon loskoppeln zu können, ist jedes Sprachkonstrukt in C direkt auf die genaue Umsetzung auf dem Computer abzubilden.
Das kann nicht nur generell die Entwicklung erleichtern, sondern auch bei der Entwicklung von \ac{UI}s im besonderen Maße hilfreich sein, da die Performanz der Anwendung hier eine große Rolle für die Usability spielt.
Und eine transparente Sprache kann die Entwicklung performanter Anwendungen, da die Arbeit, die von der CPU für eine Aufgabe getan werden muss, leichter zu sehen ist.

Auch erleichtert die Verwendung von C die direkte Nutzung der Windows-API, da die Verwendung eines \ac{FFI}s ausbleibt.
Das hat sich vor allem bei der Entwicklung der Kommunikation (siehe Abschnitt \ref{umsetzungSW-Kommunikation}) als sinnvoll erwiesen.
Zuletzt ist auch noch amzumerken, dass ein substantiver Beweggrund für die Wahl von C in der hohen Erfahrung der Entwicklerin mit der Sprache lag. % @Note(Val): Sollte ich mich in der 3. Person so selbst benennen?

% @TODO(Val): Abschnitt(e) zur Verwendung von Libraries???
% Neben der Wahl der Programmiersprache wurde ebenfalls entschieden eine möglichst minimale Anzahl von Libraries zu verwenden.
% Libraries wollen meist in vielen unterschiedlichen Situationen nutzbar sein und haben entsprechend allgemeinere Annahmen als Code, der speziell für einen Anwendungsfall geschrieben wurde.
% Libraries verstecken außerdem oftmals die Arbeit, die für eine Aufgabe geleistet werden muss.
% Da, wie eingangs erwähnt, eine hohe Transparenz des Codes erwünscht ist, ist dies hier als Nachteil von Libraries gesehen, auch wenn eben jene Eigenschaft des Versteckens oft als Vorteil von Libraries genannt wird. % @TODO(Val): Quelle dafür einfügen
% Zuletzt bringen Libraries auch immer die Möglichkeit von Bugs oder unerwünschten Nebeneffekten.

% Libraries können außerdem sowohl die Verständlichkeit und Wartbarkeit des Codes erhöhen als auch verringern.
% Die Verwendung einer Library erfordert, dass die Entwickler:in die API sowie die Nebeneffekte der Library versteht.
% Gleichzeitig kann eine Library auch zusammenhängenden Code örtlich sortieren, verwendeten Operationen verständliche Namen geben und deren Komplexität verstecken, bis die Entwickler:in diese Komplexität betrachten muss bzw. will.

% @TODO(Val): Abschnitt zur Verwendung von Prototypen während Konzept-Phase???
% Während der Implementierung kam es zu keinen Änderungen zu dem in Kapitel \ref{vorgehenSW} vorgestellten Plans.
% Das liegt u.a. daran, dass Teile der Konzeption während der Entwicklung von Prototypen, erstellt wurden.
% So wurden beispielsweise die Möglichkeiten der Kommunikation zwischen \ac{UI} und \ac{MC} mithilfe von Prototypen gefunden.
% Basierend auf den Ergebnissen des Prototypen, wurden dann die Vor- und Nachteile unterschiedlicher Ansätze gefunden und die in Kapitel \ref{vorgehenSW} genannten Entscheidungen getroffen.

Folgend sollen besonders interessante Teile der Entwicklung noch genauer betrachtet werden.
Da die \ac{UI} den größten Teil der endgültigen Codebasis stellt, ist es interessant zu sehen, wie der oben erwähnte Bottom-Up Ansatz hier abgeschnitten hat.
Entsprechend wird in Abschnitt \ref{umsetzungSW-UI} auf die entstandene Architektur der \ac{UI} eingegangen.
Auch sollen Schwierigkeiten, die während der Programmierung aufgekommen sind, beschrieben werden.
Hier sind vor allem die Implementierung der Kommmunikation (siehe Abschnitt \ref{umsetzungSW-Kommunikation}) und des \ac{MC}s (siehe Abschnitt \ref{umsetzungSW-MC}) von Interesse.


\section{UI} \label{umsetzungSW-UI}
- Grundlagen: Immediate vs. Retained Mode UI \newline
- Cached Immediate Mode \newline
- Generelle Diskussion bzgl. API-Design vllt \newline
- Raylib API \newline
- Parallelisierung basierend auf unabhängigen Codepaths (siehe Blogpost dazu) \newline
- Thread-Kommunikation über geteilten read-only Speicher \& Mutexes wenn notwendig \newline


\section{Kommunikation} \label{umsetzungSW-Kommunikation}

Die Protokolle der Kommunikation wurden in Kapitel \ref{vorgehenSW-SPPP} detailliert spezifiziert.
Die Umsetzung des Lesens und Schreibens von Nachrichten braucht allerdings sowohl auf Seiten der \ac{UI} als auch beim \ac{MC} mehr als nur eine Möglichkeit zum De- und Enkodieren der Nachrichten.
Die Kommunikation muss nämlich in den Kontext beider Systeme eingebunden werden.
Im Folgenden soll darauf eingegangen werden, welche Schwierigkeiten und Auswirkungen diese Kontexte auf die Umsetzung der Kommunikation hatten.
Zuerst soll in Abschnitt \ref{umsetzungSW-Kommunikation-MC} die Umsetzung auf dem \ac{MC} und dann in Abschnitt \ref{umsetzungSW-Kommunikation-UI} die Umsetzung in der \ac{UI} beschrieben werden.
Trotz einiger Unterschiede gilt in beiden Fällen, dass die Kommunikation im Kontext eines Echtzeit-Systems implementiert werden muss.

\subsection{Kommunikation beim \ac{MC}} \label{umsetzungSW-Kommunikation-MC}

Der gewählte Arduino hat einen einzelnen Kern und kann keinen Code parallel laufen lassen.
Das Spielen der Musik und das Lesen bzw. Schreiben von Nachrichten an die \ac{UI} müssen entsprechend nach einander abgehandelt werden.
Der Ablauf fürs Spielen der Musik wurde in Abschnitt \ref{vorgehenSW-MC} bereits dargestellt.
Dem \ac{SPPP} Protokoll nach muss der \ac{MC} einkommende Nachrichten lesen und je nach Nachricht eine Antwort senden.
Auch kann es zu Zuständen kommen, in denen der \ac{MC} ohne Lesen einer einkommenden Nachricht von sich aus eine \enquote{Request}-Nachricht an die \ac{UI} schicken muss.

Eine naive Implementierung dieser Logik tritt jedoch bald in Probleme.
Da die Bytes kontinuierlich nacheinander eintreffen, müssen alle einkommenden Bytes in einem Buffer gespeichert werden, bevor sie als \ac{SPPP} Nachricht interpretiert werden können.
Die Standard-Bibliothek des Arduino Projekts bietet dieses Buffering für das Lesen von Daten über das \ac{UART} Protokoll bereits an.
Jedoch ist dieser Buffer nicht ausreichend, da er zu klein ist und nach gewisser Zeit wieder von vorne überschrieben wird. % @TODO(Val): Check that this is correct. Also that sentence kinda sucks

Deshalb muss ein eigener Buffer erstellt werden, der groß genug für eine \ac{SPPP} Nachricht und nicht überschrieben wird.
Der Buffer sollte jede Iteration mit den neu gelesenen Bytes befüllt werden.
Sobald genug Bytes im Buffer gesammelt wurden, kann versucht werden, diese als \ac{SPPP} Nachricht zu interpretieren.

Hier kann vorkommen, dass eine korrekte Nachricht eingetroffen ist, aber dass direk davor erst noch unsinnige Bytes angekommen sind.
Es wäre schlecht, die gesamte Nachricht deswegen wegzuschmeißen.
Stattdessen sollten nur solange die vorderen Bytes ignoriert werden, bis die Magic Bytes des \ac{SPPP} Protokolls gefunden wurden.
Um effizient von vorne durch den Buffer zu gehen, während weiterhin jede Iteration neue Bytes hinten angehängt werden können, ist die Verwendung eines Ring-Buffers empfehlenswert.

Es wurde nun gesagt, dass die Nachricht geparst werden kann, sobald genug Bytes im Buffer gelandet sind.
Hier lässt sich aber die Frage stellen, was genug Bytes sind.
Eine Nachricht besteht aus mindestens 4 Bytes - 3 Magic Bytes und 1 Byte für die ID des Nachrichtentyps.
Die längste mögliche Nachricht des Protokolls dagegen kann bis zu $262.727$ Bytes enthalten\footnote{Die längste mögliche \ac{SPPP}-Nachricht kann mit einer \enquote{New-Music}-Nachricht erstellt werden. Diese Nachricht ist zwei variabel lange Listen begrenzt. Einerseits übersendet die Nachricht eine Liste von \lstinline|PidiCmd|s, welche jeweils 4 Byte einnehmen.. Die Länge dieser Liste wird in der \enquote{Pong}-Nachricht vom \ac{MC} begrenzt, wobei die Maximallänge als 16-Bit Zahl repräsentiert werden muss. Entsprechend können höchstens $2^{16} = 65.536$ \lstinline|PidiCmd|s pro Nachricht geschickt werden. Andererseits enthält die Nachricht auch eine variabel-lange Lise von \lstinline|PlayedKey|s, welche jeweils in 3 Bytes repräsentiert werden. Da jede Taste nur einmal vorkommen darf, ist diese Länge über die Anzahl Tasten begrenzt, die im \ac{PIDI}-Format repräsentiert werden können. Da es 12 Tasten pro Oktave und $2^4=16$ Oktaven im Format gibt, können bis zu $12 \cdot 2^4 = 192$ \lstinline|PlayedKey|s übersendet werden. Zusätzlich besteht die \enquote{New-Music}-Nachricht noch aus den 3 Magic Bytes des \ac{SPPP} Protokolls, 1 Byte für die ID des Nachrichtentyps, 1 Byte für die Länge der Liste von \lstinline|PlayedKey|s und 2 Bytes für die Länge der Liste von \lstinline|PidiCmd|s. Insgesamt ergibt das dann $4 + 1 + 12 \cdot 2^4 \cdot 3 + 2 + 2^{16} \cdot 4 = 262.727$ Bytes.}.
Es ist dadurch nicht möglich zu warten, bis die maximale Anzahl von Bytes pro Nachricht angekommen sind.
Einerseits hat der gewählte Arduino nicht genug Speicherplatz für einen Buffer dieser Länge und andererseits würde dies die Antwortzeit des \ac{MC}s auf nicht akzeptable Höhen steigern.

Stattdessen muss nach dem Eintrffen von mindestens 4 Bytes geschaut werden, um welchen Nachrichtentyp es sich handelt.
Je nach Typ ist die gesamte Nachricht dann schon gelesen.
Bei Nachrichten einer fixen Länge kann gewartet werden, bis alle Bytes der Nachricht eingetroffen sind.
Bei der \enquote{Music}- und \enquote{New-Music}-Nachricht dagegen, kann aufgrund geringen Speicherplatzes nicht unbedingt gewartet werden, bis die gesamte Nachricht eingetroffen ist.
Eine alternative Lösung muss entsprechend \enquote{greedy} sein und die empfangenen Bytes der \lstinline|PidiCmd|s und \lstinline|PlayedKey|s direkt auslesen und in die zur Verfügung stehenden Buffer für die nächsten zu spielenden Noten einsortieren.
Um dies umzusetzen, muss der derzeitige Zustand gespeichert werden, damit sich nach jeder Iteration gemerkt wird, ob die nächsten Bytes einen \lstinline|PidiCmd|, einen \lstinline|PlayedKey|, den Start einer neuen Nachricht oder etwas anderes darstellt.
Alles in allem sieht die Logik für den Arduino dann dem in Listing \ref{code:Comm-MC} dargestellten Pseudocode sehr ähnlich.

\begin{UnbrokenCodePage}[style=CStyle, caption={Kommunikation beim \ac{MC}}, label={code:Comm-MC}]
// @TODO(Val): Vereinfachter Pseudocode des Arduino-Skripts hier
\end{UnbrokenCodePage}


\subsection{Kommunikation bei der \ac{UI}} \label{umsetzungSW-Kommunikation-UI}
% @Note(Val): Documentaion of COM-Ports: https://learn.microsoft.com/en-us/windows-hardware/drivers/serports/configuration-of-com-ports

Es gibt keine standardisierte, Betribssystem-übergreifende API zum Empfangen und Senden von Daten über das \ac{UART} Protokoll.
Da die \ac{UI} den Anforderungen nach nur auf Windows laufen muss, wird hier auf die Windows-spezifische API dafür zurückgegriffen.
Um dies stattdessen cross-platform zu entwickeln, müsste eine eigene Abstraktion über die Platform-spezifischen APIs für die \ac{UART} Kommunikation gefunden werden.
Fortführungen dieser Arbeit sollten den Aufwand dieser Erweiterung prüfung und ggf. umsetzen.

Auf Windows müssen COM Ports für die Kommunikation verwendet werden.
COM Ports sind serielle Ports auf Windows, die Daten über das \ac{UART} Protokoll empfangen und senden können.
Zum Lesen oder Schreiben werden diese Ports als Dateien betrachtet und die Funktionen \enquote{ReadFile} und \enquote{WriteFile} verwendet.
Alternativ bietet Windows auch asynchrone Versionen der Funktionen an, die den laufenden Thread nicht bis Abschluss der \ac{I/O}-Operation blockieren.
Weitere Möglichkeiten zum Lesen, wie zum Beispiel eine Methode fürs Polling von Dateien, gibt es nicht. % @TODO(Val): Quelle

Die naive Implementierung des Lesens von \ac{SPPP}-Nachrichten bringt mit hier ebenfalls Probleme mit sich.
Aufruf zum Lesen von $n$ Bytes blockt bis $n$ Bytes gelesen wurden oder bricht mit einer Fehlermeldung ab.
Angenommen der Aufruf der \enquote{ReadFile} Funktion läuft in einem seperaten Thread, sodass das Blockieren nicht die Interaktivität der \ac{UI} beeinflusst, bleibt trotzdem noch ein Problem.
Angenommen es sollen genau 4 Bytes gelesen werden, da auf eine \enquote{Request}-Nachricht gewartet wird.
Nun soll angenommen werden, dass zuerst ein zufälliges Byte gelesen wird, das nichts mit der Nachricht zu tun hat, bevor die Nachricht empfangen wird.
Das erste Byte soll in diesem Fall ignoriert werden, damit die Nachricht gelesen werden kann.
Wenn aber genau 4 Bytes gelesen werden, ist dies ohne das Zwischenspeichern der empfangenen Bytes in einem zusätzlichen Buffer nicht möglich.

Genau wie beim Arduino ist hier also die Verwendung eines Buffers zum Speichern der empfangenen Bytes unabdingbar.
Aus den selben Effizienzgründen wird hier ebenfalls ein Ring-Buffer verwendet.
Dem Ansatz der Semantic Compression nach, wurde hier der duplizierte Code wiederverwendbar zusammengeführt.
Um Code zwischen Arduino und \ac{UI} zu teilen, wurde eine Bibliothek erstellt, die von beiden inkludiert wird.

Zum Empfangen der Bytes muss weiterhin die \enquote{ReadFile} Funktion verwendet werden.
Hier kann sowohl die blockierende als auch die nicht blockierende Version der Funktion verwendet werden.
Die nicht blockierende Version benötigt zusätzlichen Code zum regelmäßigen Nachschauen, ob Bytes angekommen ist.
Die blockierende Version muss dagegen im einen seperaten Thread laufen, um die restliche \ac{UI} nicht zu blockieren.
Da nur dieser Thread den Ring-Buffer befüllt und der restliche Code nur aus dem Ring-Buffer liest ist eine Synchronisierung der Threads über Mutexe oder ähnliche Kontrukte nicht nötig.
Aufgrund des geringeren Entwicklungsaufwands wurde sich für die Nutzung der blockierenden Version entschieden.

Bei der naiven Implemenierung des Schreibens ist ebenfalls ein vorher unerwartetes Problem aufgetreten.
Beim Schreiben kurzer Nachrichten hat ein einfacher Aufruf der \enquote{WriteFile} Funktion mi der enkodierten Nachricht ausgreicht.
Beim Senden längerer Nachrichten - speziell bei \enquote{Music} und \enquote{New-Music} Nachrichten - wurden dagegen nicht alle Bytes vom Arduino empfangen.
Es gibt mehrere Stellen, an denen der Fehler auftreten könnte.
Es könnte sein, dass der \ac{MC} nicht schnell geng mit dem Lesen der einkommenden Bytes ist und deshalb einige Bytes überschreibt und überspringt.
Es ist auh möglich, dass Windows ein Bug beim Senden längerer Byte Arrays hat oder eine andere, nicht dokumentierte Nutzung der \enquote{WriteFile} Funktion erwartet.

Da dieses Problem erst relativ spät in der Entwicklung gefunden wurde, konnte die Quelle des Problems nicht mehr gefunden und beseitig werden.
Dies liegt zu großen Teilen daran, dass dieser Bug scheinbar nicht-deterministisch auftrat.
Auch wenn nur große Nachrichten das Problem hatten, trat der Bug nicht bei allen längeren Nachrichten auf.
Wäre noch genügend Zeit fim Projekt übrig gewesen, wäre der nächste Schritt im Identifizieren des Problems gewesen.
Um zu sehen, ob empfangene Bytes auf Seiten des Arduino überschrieben werden, könnte die verwendete Standard-Bibliothek um einen konditionalen Debug-Output erweitert werden.
Sollte dies die Problemquelle sein, könnte sie behoben werden, indem zum Beispiel ein größerer Buffer zum Zwischenspeichern der eintreffenden Bytes verwendet wird.
Sollte sich herausstellen, dass es auf Seiten des Arduinos keinen Fehler gibt, müsste stattdessen untersucht werden, was genau beim Aufruf der \enquote{WriteFile} Funktion passiert.
Da der Quellcode von Windows nicht frei verfügbar ist, würde dies einen hohen Aufwand mit sich bringen.

Wie bereits erwähnt, konnte diese Fehlersuche jedoch nicht vollzogen werden.
Nichtsdestotrotz konnte das Problem noch gelöst werden.
Experimentell wurde herausgefunden, dass der Fehler nicht auftritt, wenn höchstens 16 Byte auf einmal mit der \enquote{WriteFile} Funktion gesendet werden und ein paar Millisekunden gewartet wird, bevor die nächsten 16 Byte der Nachricht gesendet werden.
Diese Lösung funktioniert zwar, ist aber nicht unbedingt stailö
Da der Grund für den Fehler nicht bekannt ist, ist unklar warum diese Lösung genau funktioniert und unter welchen Umständen sie nicht mehr funktionieren würde.
Fortsetzungen dieserer Arbeit sollten deshalb die Fehlerquelle finden und sauberer lösen.


\section{Arduino-Programmierung} \label{umsetzungSW-MC}

Aufgrund der großen Unterschiede zwischen einem Desktop und einem \ac{MC}, war auch die Programmierung für die beiden Systeme relativ unterschiedlich.
Der größte, spürbare Unterschied ist wahrschenlich im stark begrenzten Speicherplatz zu finden.
Während der Arduino ausreichend Flash-Speicher besitzt, ist der dynamische RAM-Speicher mit 2KB stark begrenzt.
Mit der Verwendung der offiziellen Arduino IDE wird mitgeteilt, wie viel des dynamischen Speichers verwendet wird.
Dabei kann jedoch nicht berechnet werden, wie viel Speicherplatz während der Laufzeit durch lokale Variablen noch benötigt wird.
Es kann dadurch vorkommen, dass mehr Speicher benötigt wird als verfügbar ist.
In diesen Fällen wird bereits verwendeter Speicher überschrieben, was zu viel nicht erwünschten und nicht erwartbaren Verhalten führt.
Es ist mehrfach während der Entwicklung vorgekommen, dass unerklärliche Fehler aufgetreten sind, die mit einer verringerten Speichernutzung gefixt wurden.
Um einen besseren Überblick über die Anzahl wirklich verwendeten Speichers zu erhalten, wurden viele lokale Variablen zu globalen Variablen geändert.
Dadurch taucht deren Speicherplatz-Nutzung in der beim Kompilieren gezeigten Statistik verbleibenden Speichers mit auf.

Weiterhin ist die Programmierung des Arduinos durch das Ausbleiben eines Debuggers erschwert.
Während es durchaus Debugger für den Arduino gibt, benötigen diese ebenfalls eine gewisse Menge dynamischen Speichers.
Zum Finden von Problemen, die durch Speicherplatzmangel entstanden ist, sind die Debugger entsprechend ungeeignet.
Aber auch beim Finden anderer Bugs sind sie nicht weiter hilfreich, da sie selbst den Speicher zum Überlaufen bringen können.
Nichtsdestotrotz konnten Bugs über die Nutzung von Print-Statements gefunden und ausgemerzt werden.

% @TODO(Val): Rest schreiben

- Berechnung von Oktave+Note zu Aktuator-Index \newline
- Strategie für PlayedKeys Elimination \newline

% - Piano Layout (7 Oktaven, 3 Tasten davor, 1 Taste danach)\newline
% - Werte durch Ausprobieren erraten (Minimaler Wert um Motor anzukriegen; Clock-Rate)\newline
% - Konstante ‘Framerate’ ohne delay