%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Autoren des Abschnitts:
%   Val Richter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% !TEX root =  master.tex
\chapter{Umsetzung - Software} \label{umsetzungSW}
\chapterauthor{Val Richter}

\nocite{*}
% - Probleme, Schwierigkeiten, Änderungen während der Umsetzung \newline
% - vllt. kurze Code-Schnippsel von besonders interessanten Teilen

Es steht nun ein Konzept für die benötigten Datenstrukturen und das erwünschte Verhalten der Software-Komponenten.
Dieses Verhalten kann nun jedoch auf unterschiedliche Arten entwickelt werden.
Ein möglicher Ansatz für die Entwicklung sieht zum Beispiel initial eine Klassifizierung aller logischen Objekte zur Laufzeit des gewünschten Programms vor.
Daraufhin kann dann analysiert werden, wie diese Objekte miteinander kommunizieren müssen und welche Daten diese haben und teilen müssen, um das erwünschte Verhalten der Software zu bekommen.
Im Folgenden soll diese Entwicklungs-Strategie als \enquote{Top-Down}-Ansatz bezeichnet werden.
Ein Top-Down-Ansatz klingt verlockend, da es scheint, als würde damit direkt die erwünschte Software geschrieben werden können.
Oftmals scheitert dieses Vorgehen jedoch in der Praxis. % @TODO(Val): Quelle & (belegte) Gründe warum es scheitert

Ein alternativer, \enquote{Bottom-Up}-Ansatz ist der von Casey Muratori als \enquote{Semantic Compression} \cite{mur.SemanticCompression.14} Getaufte.
Statt das Programm basierend auf logischen Objekten zu teilen, wird hier stattdessen eine Teilung in Schritte des gewünschten Verhaltens vorgenommen.
Weiterhin ist diese Teilung iterativ und geschieht während der Entwicklung, statt als seperate Aufgabe davor - wie es im davor beschriebenen Top-Down-Ansatz der Fall ist.
Sobald ein Teil des erwünschten Verhaltens konkret definiert wurde, kann dies in der einfachsten Art entwickelt werden.
Hierbei werden Gedanken der Wartbarkeit erstmal ignoriert.
Auch werden Abstraktionen in diesem Schritt noch nicht fortgeführt.
Stattdessen wird hier nur betrachtet, ob das erwünschte Teilverhalten funktional richtig implementiert wurden.

Bevor nun jedoch der nächste Teil der Anwendung implementiert wird, kommt die Semantische Kompression.
Auf lang oder kurz wird es vorkommen, dass zwei Teile des Codes die selbe oder eine ähnliche Folge von Operationen durchlaufen.
Diesem Ansatz nach wird nun der Code nach solchen semantischen Duplikaten durchsucht.
Solche Duplikate können dann extrahiert werden und in einzelnen Funktionen oder Datenstrukturen komprimiert werden.
Diese Komprimierung ist dabei nicht unbedingt eine syntaktische Komprimierung sondern eine semantische \cite[vgl. ]{mur.SemanticCompression.14}.

Beide Strategien zielen am Ende auf Code mit den gleichen Attributen ab.
Der Code soll gut lesbar, wartbar und erweiterbar sein.
Der erste Ansatz nimmt dabei an, dass die Teilung in logische Objekte das Verständnis der Codebasis erleichtert.
Der Bottom-Up Ansatz streitet diese Annahme im Generellen ab und behauptet stattdessen, dass semantisch komprimierter Code besser lesbar und verständlich ist, da es keine unnötigen Abstraktionen gibt und die existierenden Abstraktionen noch so nah an der konkreten Aufgabe sind wie nötig.
Ähnlich argumentieren beide Strategien, dass sie jeweils höhere Wartbarkeit und Erweiterbarkeit liefern.
Der fundamentale Gegensatz der beiden Ansätze kann jedoch - wie an dem einen Beispiel hoffentlich sichtbar wurde - in ihrer Haltung gegenüber Abstraktion finden.

Im Top-Down Ansatz wird Abstraktion generell positiv betrachtet.
Die Entwicklung beginnt mit einer abstrakten Klassifikation vermutlich benötigter Objekte und seperiert die Entwicklung entlang dieser Objekte.
Eine falsch gewählte Struktur oder Abstraktion dieser Objekte kann die Entwicklung entsprechend stark erschweren.
Der Bottom-Up Ansatz steht Abstraktion dagegen kritisch gegenüber.
Abstraktion ist hier immer noch erwünscht, aber nur wenn die Abstraktion die Reduzierung logischer Duplizierungen mit sich bringt und nur genau so weit abstrahiert ist wie nötig.
Unnötige Abstraktion oder Abstraktion, die auf einem höheren Level als nötig für das zu lösende Problem ist, ist hier negativ konnotiert.
Weiterhin wird hier nicht angenommen, dass zu Beginn der Entwicklung genug Wissen und Expertise besteht, um eine sinnvolle Architektur für den Code finden zu können.
Stattdessen ist die Semantische Kompression ein Verfahren zum explorativen Finden einer solchen sinnvollen Architektur.
In der Implementierung dieses Projekts wurde der Ansatz der Semantic Compression verwendet, da Erfahrungen mit besser und schlechter strukturierter Software dessen Thesen eher unterstützen.

Neben dem Entwicklungsansatz gibt es noch andere Entscheidungen, die die gesamte Entwicklung beeinflussen.
So ist auch die Wahl der Programmiersprache eine substantive und weitreichende Entscheidung.
Hier wurde sich entschieden, die gesamte Implementierung in der Programmiersprache C\footnote{Streng genommen ist hier der ISO-Standard C99 gemeint \cite*[siehe ][]{iso.c99}. Der Einfachheit halber wird in dieser Arbeit jedoch nur von \enquote{C} gesprochen.} zu erstellen.
Da der \ac{MC} vergleichsweise nur sehr begrenzten Speicherplatz zur Verfügung hat, ist die manuelle Speicherverwaltung von C hier sehr wünschenswert.

Aber auch für die Entwicklung der \ac{UI}, wo der verfügbare Speicherplatz praktisch nicht begrenzt ist, wurde sich entschieden C zu verwenden.
Der hauptsächliche Grund dafür ist die Transparenz der Sprache.
Während viele Nachfolger von C versuchen ihre Semantik abstrakt halten, um die eigentliche Implementierung davon loskoppeln zu können, ist jedes Sprachkonstrukt in C direkt auf die genaue Umsetzung auf dem Computer abzubilden.
Das kann nicht nur generell die Entwicklung erleichtern, sondern auch bei der Entwicklung von \ac{UI}s im besonderen Maße hilfreich sein, da die Performanz der Anwendung hier eine große Rolle für die Usability spielt.
Und eine transparente Sprache kann die Entwicklung performanter Anwendungen, da die Arbeit, die von der CPU für eine Aufgabe getan werden muss, leichter zu sehen ist.

Auch erleichtert die Verwendung von C die direkte Nutzung der Windows-API, da die Verwendung eines \ac{FFI}s ausbleibt.
Das hat sich vor allem bei der Entwicklung der Kommunikation (siehe Abschnitt \ref{umsetzungSW-Kommunikation}) als sinnvoll erwiesen.
Zuletzt ist auch noch amzumerken, dass ein substantiver Beweggrund für die Wahl von C in der hohen Erfahrung der Entwicklerin mit der Sprache lag. % @Note(Val): Sollte ich mich in der 3. Person so selbst benennen?

% @TODO(Val): Abschnitt(e) zur Verwendung von Libraries???
% Neben der Wahl der Programmiersprache wurde ebenfalls entschieden eine möglichst minimale Anzahl von Libraries zu verwenden.
% Libraries wollen meist in vielen unterschiedlichen Situationen nutzbar sein und haben entsprechend allgemeinere Annahmen als Code, der speziell für einen Anwendungsfall geschrieben wurde.
% Libraries verstecken außerdem oftmals die Arbeit, die für eine Aufgabe geleistet werden muss.
% Da, wie eingangs erwähnt, eine hohe Transparenz des Codes erwünscht ist, ist dies hier als Nachteil von Libraries gesehen, auch wenn eben jene Eigenschaft des Versteckens oft als Vorteil von Libraries genannt wird. % @TODO(Val): Quelle dafür einfügen
% Zuletzt bringen Libraries auch immer die Möglichkeit von Bugs oder unerwünschten Nebeneffekten.

% Libraries können außerdem sowohl die Verständlichkeit und Wartbarkeit des Codes erhöhen als auch verringern.
% Die Verwendung einer Library erfordert, dass die Entwickler:in die API sowie die Nebeneffekte der Library versteht.
% Gleichzeitig kann eine Library auch zusammenhängenden Code örtlich sortieren, verwendeten Operationen verständliche Namen geben und deren Komplexität verstecken, bis die Entwickler:in diese Komplexität betrachten muss bzw. will.

% @TODO(Val): Abschnitt zur Verwendung von Prototypen während Konzept-Phase???
% Während der Implementierung kam es zu keinen Änderungen zu dem in Kapitel \ref{vorgehenSW} vorgestellten Plans.
% Das liegt u.a. daran, dass Teile der Konzeption während der Entwicklung von Prototypen, erstellt wurden.
% So wurden beispielsweise die Möglichkeiten der Kommunikation zwischen \ac{UI} und \ac{MC} mithilfe von Prototypen gefunden.
% Basierend auf den Ergebnissen des Prototypen, wurden dann die Vor- und Nachteile unterschiedlicher Ansätze gefunden und die in Kapitel \ref{vorgehenSW} genannten Entscheidungen getroffen.

Folgend sollen besonders interessante Teile der Entwicklung noch genauer betrachtet werden.
Da die \ac{UI} den größten Teil der endgültigen Codebasis stellt, ist es interessant zu sehen, wie der oben erwähnte Bottom-Up Ansatz hier abgeschnitten hat.
Entsprechend wird in Abschnitt \ref{umsetzungSW-UI} auf die entstandene Architektur der \ac{UI} eingegangen.
Auch sollen Schwierigkeiten, die während der Programmierung aufgekommen sind, beschrieben werden.
Hier sind vor allem die Implementierung der Kommmunikation (siehe Abschnitt \ref{umsetzungSW-Kommunikation}) und des \ac{MC}s (siehe Abschnitt \ref{umsetzungSW-MC}) von Interesse.


\section{UI} \label{umsetzungSW-UI}
- Grundlagen: Immediate vs. Retained Mode UI \newline
- Cached Immediate Mode \newline
- Generelle Diskussion bzgl. API-Design vllt \newline
- Raylib API \newline
- Parallelisierung basierend auf unabhängigen Codepaths (siehe Blogpost dazu) \newline
- Thread-Kommunikation über geteilten read-only Speicher \& Mutexes wenn notwendig \newline


\section{Kommunikation} \label{umsetzungSW-Kommunikation}

Die Protokolle der Kommunikation wurden in Kapitel \ref{vorgehenSW-SPPP} detailliert spezifiziert.
Die Umsetzung des Lesens und Schreibens von Nachrichten braucht allerdings sowohl auf Seiten der \ac{UI} als auch beim \ac{MC} mehr als nur eine Möglichkeit zum De- und Enkodieren der Nachrichten.
Die Kommunikation muss nämlich in den Kontext beider Systeme eingebunden werden.
Im Folgenden soll darauf eingegangen werden, welche Schwierigkeiten und Auswirkungen diese Kontexte auf die Umsetzung der Kommunikation hatten.
Zuerst soll in Abschnitt \ref{umsetzungSW-Kommunikation-MC} die Umsetzung auf dem \ac{MC} und dann in Abschnitt \ref{umsetzungSW-Kommunikation-UI} die Umsetzung in der \ac{UI} beschrieben werden.
Trotz einiger Unterschiede gilt in beiden Fällen, dass die Kommunikation im Kontext eines Echtzeit-Systems implementiert werden muss.

\subsection{Kommunikation beim \ac{MC}} \label{umsetzungSW-Kommunikation-MC}

Der gewählte Arduino hat einen einzelnen Kern und kann keinen Code parallel laufen lassen.
Das Spielen der Musik und das Lesen bzw. Schreiben von Nachrichten an die \ac{UI} müssen entsprechend nach einander abgehandelt werden.
Der Ablauf fürs Spielen der Musik wurde in Abschnitt \ref{vorgehenSW-MC} bereits dargestellt.
Dem \ac{SPPP} Protokoll nach muss der \ac{MC} einkommende Nachrichten lesen und je nach Nachricht eine Antwort senden.
Auch kann es zu Zuständen kommen, in denen der \ac{MC} ohne Lesen einer einkommenden Nachricht von sich aus eine \enquote{Request}-Nachricht an die \ac{UI} schicken muss.

Eine naive Implementierung dieser Logik tritt jedoch bald in Probleme.
Da die Bytes kontinuierlich nacheinander eintreffen, müssen alle einkommenden Bytes in einem Buffer gespeichert werden, bevor sie als \ac{SPPP} Nachricht interpretiert werden können.
Die Standard-Bibliothek des Arduino Projekts bietet dieses Buffering für das Lesen von Daten über das \ac{UART} Protokoll bereits an.
Jedoch ist dieser Buffer nicht ausreichend, da er zu klein ist und nach gewisser Zeit wieder von vorne überschrieben wird. % @TODO(Val): Check that this is correct. Also that sentence kinda sucks

Deshalb muss ein eigener Buffer erstellt werden, der groß genug für eine \ac{SPPP} Nachricht und nicht überschrieben wird.
Der Buffer sollte jede Iteration mit den neu gelesenen Bytes befüllt werden.
Sobald genug Bytes im Buffer gesammelt wurden, kann versucht werden, diese als \ac{SPPP} Nachricht zu interpretieren.

Hier kann vorkommen, dass eine korrekte Nachricht eingetroffen ist, aber dass direk davor erst noch unsinnige Bytes angekommen sind.
Es wäre schlecht, die gesamte Nachricht deswegen wegzuschmeißen.
Stattdessen sollten nur solange die vorderen Bytes ignoriert werden, bis die Magic Bytes des \ac{SPPP} Protokolls gefunden wurden.
Um effizient von vorne durch den Buffer zu gehen, während weiterhin jede Iteration neue Bytes hinten angehängt werden können, ist die Verwendung eines Ring-Buffers empfehlenswert.

Es wurde nun gesagt, dass die Nachricht geparst werden kann, sobald genug Bytes im Buffer gelandet sind.
Hier lässt sich aber die Frage stellen, was genug Bytes sind.
Eine Nachricht besteht aus mindestens 4 Bytes - 3 Magic Bytes und 1 Byte für die ID des Nachrichtentyps.
Die längste mögliche Nachricht des Protokolls dagegen kann bis zu $196.999$ Bytes enthalten\footnote{Die längste mögliche \ac{SPPP}-Nachricht kann mit einer \enquote{New-Music}-Nachricht erstellt werden. Diese Nachricht ist zwei variabel lange Listen begrenzt. Einerseits übersendet die Nachricht eine Liste von \lstinline|PidiCmd|s, welche jeweils 3 Byte einnehmen.. Die Länge dieser Liste wird in der \enquote{Pong}-Nachricht vom \ac{MC} begrenzt, wobei die Maximallänge als 16-Bit Zahl repräsentiert werden muss. Entsprechend können höchstens $2^{16} = 65.536$ \lstinline|PidiCmd|s pro Nachricht geschickt werden. Andererseits enthält die Nachricht auch eine variabel-lange Lise von \lstinline|PlayedKey|s, welche jeweils in 2 Bytes repräsentiert werden. Da jede Taste nur einmal vorkommen darf, ist diese Länge über die Anzahl Tasten begrenzt, die im \ac{PIDI}-Format repräsentiert werden können. Da es 12 Tasten pro Oktave und $2^4=16$ Oktaven im Format gibt, können bis zu $12 \cdot 2^4 = 192$ \lstinline|PlayedKey|s übersendet werden. Zusätzlich besteht die \enquote{New-Music}-Nachricht noch aus den 3 Magic Bytes des \ac{SPPP} Protokolls, 1 Byte für die ID des Nachrichtentyps, 1 Byte für die Länge der Liste von \lstinline|PlayedKey|s und 2 Bytes fpr die Länge der Liste von \lstinline|PidiCmd|s. Insgesamt ergibt das dann $4 + 1 + 12 \cdot 2^4 \cdot 2 + 2 + 2^{16} \cdot 3 = 196.999$ Bytes.}.
Es ist dadurch nicht möglich zu warten, bis die maximale Anzahl von Bytes pro Nachricht angekommen sind.
Einerseits hat der gewählte Arduino nicht genug Speicherplatz für einen Buffer dieser Länge und andererseits würde dies die Antwortzeit des \ac{MC}s auf nicht akzeptable Höhen steigern.

Stattdessen muss nach dem Eintrffen von mindestens 4 Bytes geschaut werden, um welchen Nachrichtentyp es sich handelt.
Je nach Typ ist die gesamte Nachricht dann schon gelesen.
Bei Nachrichten einer fixen Länge kann gewartet werden, bis alle Bytes der Nachricht eingetroffen sind.
Bei der \enquote{Music}- und \enquote{New-Music}-Nachricht dagegen, kann aufgrund geringen Speicherplatzes nicht unbedingt gewartet werden, bis die gesamte Nachricht eingetroffen ist.
Eine alternative Lösung muss entsprechend \enquote{greedy} sein und die empfangenen Bytes der \lstinline|PidiCmd|s und \lstinline|PlayedKey|s direkt auslesen und in die zur Verfügung stehenden Buffer für die nächsten zu spielenden Noten einsortieren.
Um dies umzusetzen, muss der derzeitige Zustand gespeichert werden, damit sich nach jeder Iteration gemerkt wird, ob die nächsten Bytes einen \lstinline|PidiCmd|, einen \lstinline|PlayedKey|, den Start einer neuen Nachricht oder etwas anderes darstellt.
Alles in allem sieht die Logik für den Arduino dann dem in Listing \ref{code:Comm-MC} dargestellten Pseudocode sehr ähnlich.

\begin{UnbrokenCodePage}[style=CStyle, caption={Kommunikation beim \ac{MC}}, label={code:Comm-MC}]
// @TODO(Val): Vereinfachter Pseudocode des Arduino-Skripts hier
\end{UnbrokenCodePage}


\subsection{Kommunikation beim \ac{UI}} \label{umsetzungSW-Kommunikation-UI}
- Finden von COM-Ports (EnumPorts vs. Register, etc.) \newline
- Lesen/Schreiben wie bei Dateien \newline
- keine native Möglichkeit fürs Polling \newline
- Synchrones Lesen einer gesamten Nachricht kann zu langem Blocken führen \newline
- Asynchrones Lesn funktioniert nicht \newline
- Lesen einzelner Bytes zum Befüllen eines buffers (symmetrisch zu MC) \newline
- Lesen in Endlosschleife in eigenem Thread \newline
- Schreiben in Chunks (Chunk-Größe über Ausprobieren herausgefunden) \newline
% @Note(Val): Documentaion of COM-Ports: https://learn.microsoft.com/en-us/windows-hardware/drivers/serports/configuration-of-com-ports


\section{Arduino-Programmierung} \label{umsetzungSW-MC}

- Arduino-Programmierung \newline
	- Bugs durch begrenzten Speicherplatz \newline
	- Berechnung von Oktave+Note zu Aktuator-Index \newline
	- Strategie für PlayedKeys Elimination \newline
- Code der zwischen UI und MC geteilt wurde \newline

% - Piano Layout (7 Oktaven, 3 Tasten davor, 1 Taste danach)\newline
% - Maximale Anzahl gleichzeitig laufender Motoren\newline
% - Werte durch Ausprobieren erraten (Minimaler Wert um Motor anzukriegen; Clock-Rate)\newline
% - Begrenzter Speicherplatz\newline
% - Konstante ‘Framerate’ ohne delay
