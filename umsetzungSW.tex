%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Autoren des Abschnitts:
%   Val Richter
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% !TEX root =  master.tex
\chapter{Umsetzung - Software} \label{umsetzungSW}
\chapterauthor{Val Richter}

Nachdem alle Software-Komponenten spezifiziert waren, mussten diese umgesetzt werden.
Die Entwicklung der Software lief größtenteils parallel zur Umsetzung des \enquote{Piano Player}s.
Gegen Ende der Entwicklungsphase, als genug Teile der Schaltung standen, wurden die Ausgaben des \ac{MC}s beim Spielen von Musikstücken über LEDs getestet.
In dieser Phase wurden viele Fehler gefunden und behoben, als müsste die Wichtigkeit von Tests nochmal unterstreicht werden.

Bevor auf die Umsetzung der Komponenten speziell eingegangen wird, soll hier kurz die Wahl der Programmiersprache der Implementierung motiviert werden. \newline
Es wurde sich entschieden, die gesamte Implementierung der Software in der Programmiersprache C\footnote{Streng genommen ist hier der ISO-Standard C99 gemeint \cite*[siehe ][]{iso.c99}. Der Einfachheit halber wird in dieser Arbeit jedoch nur von \enquote{C} gesprochen.} zu erstellen.
Da der \ac{MC} vergleichsweise nur sehr begrenzten Speicherplatz zur Verfügung hat, ist die manuelle Speicherverwaltung von C hier sehr wünschenswert.
Weiterhin ist die Sprache sehr simpel und elegant und erzwingt keinen Programmierstil, wie funktionale oder Objekt-orienterte Sprachen es oft tun.

Zuletzt erleichtert die Verwendung von C die direkte Nutzung der Windows-API, da die Verwendung eines \ac{FFI}s ausbleibt.
Das hat sich vor allem bei der Entwicklung der Kommunikation (siehe Abschnitt \ref{umsetzungSW-Kommunikation}) als sinnvoll erwiesen.
Zuletzt ist auch noch amzumerken, dass ein substantiver Beweggrund für die Wahl von C in der hohen Erfahrung der Entwicklerin mit der Sprache lag.

Folgend sollen besonders interessante Teile der Entwicklung noch genauer betrachtet werden.
Abschnitt \ref{umsetzungSW-UI} geht dabei auf die Entwicklung von \ac{SAM} ein, während Abschnitt \ref{umsetzungSW-Kommunikation} Schwierigkeiten bei der Umsetzung der Kommunikation und Abschnitt \ref{umsetzungSW-MC} Herausforderungen bei der Programmierung des \ac{MC}s beschreibt.


\section{Desktop Anwendung} \label{umsetzungSW-UI}

Die Umsetzung der Anwendung \ac{SAM} wurde anhand der in Kapitel \ref{vorgehenSW-UI-code} ausgearbeiteten Architektur erledigt.
Die Anwendung konnte aufgrund der begrenzten Zeit leider nicht vollständig umgesetzt werden, ist für die beiden Haupt-Use-Cases aber funktionsfähig. \newline
Das heißt, dass neue Musikstücke zum Katalog hinzugefügt werden können und alle Musikstücke im Katalog wiedergegeben werden können.
Auch die Umsetzung der Kontroll-Elemente zum Pausieren/Fortfahren der Musik und der Anpassung der Lautstärke und Wiedergabegeschwindigkeit wurden implementiert und getestet.
Zuletzt wurde sogar die Navigation im Musikstück umgesetzt.

Somit wurden alle Anforderungen an die Anwendung mit mittlerer oder hoher Priorität umgesetzt (Anforderungen A9-A12 in Tabelle \ref{table:anforderungen}).
Nur die Anforderung A13 wurde nich umgesetzt, das heißt, dass Musikstücke im Katalog zurzeit nicht umbenannt oder entfernt werden können.

Weiterhin gibt es bei den erfüllten Anforderungen zu Teilen Limitationen, die hier kurz benannt werden sollen.

Die \ac{MIDI}-Integration, Anforderung A12, scheint noch einige Fehler aufzuweisen, auch wenn es bei den meiste getetesten \ac{MIDI}-Dateien die erwarteten \ac{PIDI}-Dateien ausgibt.
Zum Testen der Integration, wurde ein Skript geschrieben, dass aus einer \ac{PIDI}-Datei wieder eine \ac{MIDI}-Datei erstellt.
Da viele Metadaten absichtlich bei der Transformation ins \ac{PIDI}-Format verloren gehen, kann die neue \ac{MIDI}-Datei nicht einfach mit der alten \ac{MIDI}-Datei verglichen werden.
Stattdessen werden bei dem Test beide Dateien abgespielt, um zu hören, ob es Unterschiede in den Dateien gibt.
Diese Methode findet subtile Fehler zwar nicht zuverlässig, das ist aber kein größeres Problem, da subtile Fehler auch die Qualität beim Spielen über den \enquote{Piano Player} nur gering mindern.

Bei der \ac{MIDI}-Integration wurde weiterhin eine Entscheidung getroffen, die den endgültigen Klang stark beeinflusst und weder unbedingt korrekt noch falsch ist. \newline
\ac{MIDI}-Dateien können mehrere Instrumente in einem Stück haben, wobei keins der Instrumente ein Klavier sein muss. \newline
Da es den geringsten Aufwand mit sich brachte und sinnvoll schien, wurde sich bei der Entwicklung entschieden, alle Instrumente zusammen zu nehmen und auf dem Klavier spielen zu lassen, unabhängig davon, ob es originell von einem Klavier gespielt wurde.
Wenn aus einem Orchester-Stück nur der Teil des Pianos vom \enquote{Piano Player} gespielt werden sollte, ist das hier nicht möglich. \newline
Eine mögliche Verbesserung würde hier den Nutzer:innen mehrere Möglichkeiten anbieten, um nur bestimmte oder alle Instrumente aus der \ac{MIDI}-Datei zu übernehmen.

Außerdem ist noch zu erwähnen, dass das \ac{UI}-Design des Prototypen nicht besonders ansprechend ist.
Die Abbildungen \ref{img:ui-start}, \ref{img:ui-dnd}, \ref{img:ui-rename}, \ref{img:ui-play} zeigen das derzeitige Aussehen von \ac{SAM}.

\begin{figure}[htbp]
	\centering
	\includegraphics*[width=0.8\textwidth]{img/ui-start}
	\caption{Screenshot der Startseite in \ac{SAM}}
	\label{img:ui-start}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics*[width=0.8\textwidth]{img/ui-dnd}
	\caption{Screenshot der Import-Seite in \ac{SAM}}
	\label{img:ui-dnd}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics*[width=0.8\textwidth]{img/ui-rename}
	\caption{Screenshot der Umbenennung beim Import in \ac{SAM}}
	\label{img:ui-rename}
\end{figure}

\begin{figure}[htbp]
	\centering
	\includegraphics*[width=0.8\textwidth]{img/ui-play}
	\includegraphics*[width=0.8\textwidth]{img/ui-play-2}
	\caption{Screenshots der Wiedergabe in \ac{SAM}}
	\label{img:ui-play}
\end{figure}

\section{Kommunikation} \label{umsetzungSW-Kommunikation}

Die Protokolle der Kommunikation wurden in Kapitel \ref{vorgehenSW-SPPP} detailliert spezifiziert.
Die Umsetzung des Lesens und Schreibens von Nachrichten braucht allerdings sowohl auf Seiten der Desktop Anwendung als auch beim \ac{MC} mehr als nur eine Möglichkeit zum De- und Enkodieren der Nachrichten.
Die Kommunikation muss nämlich in den Kontext beider Systeme eingebunden werden.
Im Folgenden soll darauf eingegangen werden, welche Schwierigkeiten und Auswirkungen diese Kontexte auf die Umsetzung der Kommunikation hatten.
Zuerst soll in Abschnitt \ref{umsetzungSW-Kommunikation-MC} die Umsetzung auf dem \ac{MC} und dann in Abschnitt \ref{umsetzungSW-Kommunikation-UI} die Umsetzung in \ac{SAM} beschrieben werden.
Trotz einiger Unterschiede gilt in beiden Fällen, dass die Kommunikation im Kontext eines Echtzeit-Systems implementiert werden muss.

\subsection{Kommunikation auf dem \ac{MC}} \label{umsetzungSW-Kommunikation-MC}

Der gewählte Arduino hat einen einzelnen Kern und kann keinen Code parallel laufen lassen.
Das Spielen der Musik und das Lesen bzw. Schreiben von Nachrichten an \ac{SAM} müssen entsprechend nach einander abgehandelt werden.
Der Ablauf fürs Spielen der Musik wurde in Abschnitt \ref{vorgehenSW-MC} bereits dargestellt.
Dem \ac{SPPP} Protokoll nach muss der \ac{MC} einkommende Nachrichten lesen und je nach Nachricht eine Antwort senden.
Auch kann es zu Zuständen kommen, in denen der \ac{MC} ohne Lesen einer einkommenden Nachricht von sich aus eine \enquote{Request}-Nachricht an \ac{SAM} schicken muss.

Eine naive Implementierung dieser Logik tritt jedoch bald in Probleme.
Da die Bytes kontinuierlich nacheinander eintreffen, müssen alle einkommenden Bytes in einem Buffer gespeichert werden, bevor sie als \ac{SPPP} Nachricht interpretiert werden können.
Die Standard-Bibliothek des Arduino Projekts bietet dieses Buffering für das Lesen von Daten über das \ac{UART} Protokoll bereits an.
Jedoch ist dieser Buffer nicht ausreichend, da er zu klein ist und nach gewisser Zeit wieder von vorne überschrieben wird.

Deshalb muss ein eigener Buffer erstellt werden, der groß genug für eine \ac{SPPP} Nachricht und nicht überschrieben wird.
Der Buffer sollte jede Iteration mit den neu gelesenen Bytes befüllt werden.
Sobald genug Bytes im Buffer gesammelt wurden, kann versucht werden, diese als \ac{SPPP} Nachricht zu interpretieren.

Hier kann vorkommen, dass eine korrekte Nachricht eingetroffen ist, aber dass direk davor erst noch unsinnige Bytes angekommen sind.
Es wäre schlecht, die gesamte Nachricht deswegen wegzuschmeißen.
Stattdessen sollten nur solange die vorderen Bytes ignoriert werden, bis die Magic Bytes des \ac{SPPP} Protokolls gefunden wurden.
Um effizient von vorne durch den Buffer zu gehen, während weiterhin jede Iteration neue Bytes hinten angehängt werden können, ist die Verwendung eines Ring-Buffers empfehlenswert.

Es wurde nun gesagt, dass die Nachricht geparst werden kann, sobald genug Bytes im Buffer gelandet sind.
Hier lässt sich aber die Frage stellen, was genug Bytes sind.
Eine Nachricht besteht aus mindestens 4 Bytes - 3 Magic Bytes und 1 Byte für die ID des Nachrichtentyps.
Die längste mögliche Nachricht des Protokolls dagegen kann bis zu $262.727$ Bytes enthalten\footnote{Die längste mögliche \ac{SPPP}-Nachricht kann mit einer \enquote{New-Music}-Nachricht erstellt werden. Diese Nachricht ist zwei variabel lange Listen begrenzt. Einerseits übersendet die Nachricht eine Liste von \lstinline|PidiCmd|s, welche jeweils 4 Byte einnehmen.. Die Länge dieser Liste wird in der \enquote{Pong}-Nachricht vom \ac{MC} begrenzt, wobei die Maximallänge als 16-Bit Zahl repräsentiert werden muss. Entsprechend können höchstens $2^{16} = 65.536$ \lstinline|PidiCmd|s pro Nachricht geschickt werden. Andererseits enthält die Nachricht auch eine variabel-lange Lise von \lstinline|PlayedKey|s, welche jeweils in 3 Bytes repräsentiert werden. Da jede Taste nur einmal vorkommen darf, ist diese Länge über die Anzahl Tasten begrenzt, die im \ac{PIDI}-Format repräsentiert werden können. Da es 12 Tasten pro Oktave und $2^4=16$ Oktaven im Format gibt, können bis zu $12 \cdot 2^4 = 192$ \lstinline|PlayedKey|s übersendet werden. Zusätzlich besteht die \enquote{New-Music}-Nachricht noch aus den 3 Magic Bytes des \ac{SPPP} Protokolls, 1 Byte für die ID des Nachrichtentyps, 1 Byte für die Länge der Liste von \lstinline|PlayedKey|s und 2 Bytes für die Länge der Liste von \lstinline|PidiCmd|s. Insgesamt ergibt das dann $4 + 1 + 12 \cdot 2^4 \cdot 3 + 2 + 2^{16} \cdot 4 = 262.727$ Bytes.}.
Es ist dadurch nicht möglich zu warten, bis die maximale Anzahl von Bytes pro Nachricht angekommen sind.
Einerseits hat der gewählte Arduino nicht genug Speicherplatz für einen Buffer dieser Länge und andererseits würde dies die Antwortzeit des \ac{MC}s auf nicht akzeptable Höhen steigern.

Stattdessen muss nach dem Eintrffen von mindestens 4 Bytes geschaut werden, um welchen Nachrichtentyp es sich handelt.
Je nach Typ ist die gesamte Nachricht dann schon gelesen.
Bei Nachrichten einer fixen Länge kann gewartet werden, bis alle Bytes der Nachricht eingetroffen sind.
Bei der \enquote{Music}- und \enquote{New-Music}-Nachricht dagegen, kann aufgrund geringen Speicherplatzes nicht unbedingt gewartet werden, bis die gesamte Nachricht eingetroffen ist.
Eine alternative Lösung muss entsprechend \enquote{greedy} sein und die empfangenen Bytes der \lstinline|PidiCmd|s und \lstinline|PlayedKey|s direkt auslesen und in die zur Verfügung stehenden Buffer für die nächsten zu spielenden Noten einsortieren.
Um dies umzusetzen, muss der derzeitige Zustand gespeichert werden, damit sich nach jeder Iteration gemerkt wird, ob die nächsten Bytes einen \lstinline|PidiCmd|, einen \lstinline|PlayedKey|, den Start einer neuen Nachricht oder etwas anderes darstellt.


\subsection{Kommunikation auf der Desktop Anwendung} \label{umsetzungSW-Kommunikation-UI}

Es gibt keine standardisierte, Betribssystem-übergreifende API zum Empfangen und Senden von Daten über das \ac{UART} Protokoll.
Da \ac{SAM} den Anforderungen nach nur auf Windows laufen muss, wird hier auf die Windows-spezifische API dafür zurückgegriffen.
Um dies stattdessen cross-platform zu entwickeln, müsste eine eigene Abstraktion über die Platform-spezifischen APIs für die \ac{UART} Kommunikation gefunden werden.
Fortführungen dieser Arbeit sollten den Aufwand dieser Erweiterung prüfung und ggf. umsetzen.

Auf Windows werden sogenannte COM Ports für die serielle Kommunikation über das \ac{UART} Protokoll verwendet \cite[vgl.][]{mar.ConfigurationCOMPorts.22}.
Zum Lesen oder Schreiben werden diese Ports als Dateien betrachtet und die Funktionen \enquote{ReadFile} und \enquote{WriteFile} verwendet \cites[vgl.][Kapitel 4]{den.SerialCommunications.10}[][S. 3]{bay.WindowsSerialPort.08}.
Alternativ bietet Windows auch asynchrone Versionen der Funktionen an, die den laufenden Thread nicht bis Abschluss der \ac{I/O}-Operation blockieren \cite[vgl.][Kapitel 4]{den.SerialCommunications.10}. \newline
Das Lesen von COM Ports kann entweder in einer Endlosschleife wiederholt werden, um alle eingehenden Bytes zu erhalten, oder es kann ein sogenannter \enquote{\ac{I/O} Completion Port} verwendet werden, um über das Eintreffen von Bytes von Windows informiert zu werden \cite[vgl.][]{ash.CompletionPortsWin32.22}.
Da diese Funktionalität erst sehr spät in die Entwicklung gefunden wurde, wurde sie weder verwendet noch getestet.

Die naive Implementierung des Lesens von \ac{SPPP}-Nachrichten bringt mit hier ebenfalls Probleme mit sich.
Aufruf zum Lesen von $n$ Bytes blockt bis $n$ Bytes gelesen wurden oder bricht mit einer Fehlermeldung ab.
Angenommen der Aufruf der \enquote{ReadFile} Funktion läuft in einem seperaten Thread, sodass das Blockieren nicht die Interaktivität der \ac{UI} beeinflusst, so bleibt trotzdem noch ein Problem.
Angenommen es sollen genau 4 Bytes gelesen werden, da auf eine \enquote{Request}-Nachricht gewartet wird.
Nun soll angenommen werden, dass zuerst ein zufälliges Byte gelesen wird, das nichts mit der Nachricht zu tun hat, bevor die Nachricht empfangen wird.
Das erste Byte soll in diesem Fall ignoriert werden, damit die Nachricht gelesen werden kann.
Wenn aber genau 4 Bytes gelesen werden, ist dies ohne das Zwischenspeichern der empfangenen Bytes in einem zusätzlichen Buffer nicht möglich.

Genau wie beim Arduino ist hier also die Verwendung eines Buffers zum Speichern der empfangenen Bytes unabdingbar.
Aus den selben Effizienzgründen wird hier ebenfalls ein Ring-Buffer verwendet.
Dem Ansatz der Semantic Compression nach, wurde hier der duplizierte Code wiederverwendbar zusammengeführt.
Um Code zwischen Arduino und \ac{SAM} zu teilen, wurde eine Bibliothek erstellt, die von beiden inkludiert wird.

Zum Empfangen der Bytes muss weiterhin die \enquote{ReadFile} Funktion verwendet werden.
Hier kann sowohl die blockierende als auch die nicht blockierende Version der Funktion verwendet werden.
Die nicht blockierende Version benötigt zusätzlichen Code zum regelmäßigen Nachschauen, ob Bytes angekommen ist.
Die blockierende Version muss dagegen im einen seperaten Thread laufen, um die restliche Anwendung nicht zu blockieren.
Da nur dieser Thread den Ring-Buffer befüllt und der restliche Code nur aus dem Ring-Buffer liest ist eine Synchronisierung der Threads über Mutexe oder ähnliche Kontrukte nicht nötig.
Aufgrund des geringeren Entwicklungsaufwands wurde sich für die Nutzung der blockierenden Version entschieden.

Bei der naiven Implemenierung des Schreibens ist ebenfalls ein vorher unerwartetes Problem aufgetreten.
Beim Schreiben kurzer Nachrichten hat ein einfacher Aufruf der \enquote{WriteFile} Funktion mit der enkodierten Nachricht ausgreicht.
Beim Senden längerer Nachrichten - speziell bei \enquote{Music} und \enquote{New-Music} Nachrichten - wurden dagegen nicht alle Bytes vom Arduino empfangen.
Es gibt mehrere Stellen, an denen der Fehler auftreten könnte.
Es könnte sein, dass der \ac{MC} nicht schnell geng mit dem Lesen der einkommenden Bytes ist und deshalb einige Bytes überschreibt und überspringt.
Es ist auh möglich, dass Windows ein Bug beim Senden längerer Byte Arrays hat oder eine andere, nicht dokumentierte Nutzung der \enquote{WriteFile} Funktion erwartet.

Da dieses Problem erst relativ spät in der Entwicklung gefunden wurde, konnte die Quelle des Problems nicht mehr gefunden und beseitig werden.
Dies liegt zu großen Teilen daran, dass dieser Bug scheinbar nicht-deterministisch auftrat.
Auch wenn nur große Nachrichten das Problem hatten, trat der Bug nicht bei allen längeren Nachrichten auf.
Wäre noch genügend Zeit fim Projekt übrig gewesen, wäre der nächste Schritt im Identifizieren des Problems gewesen.
Um zu sehen, ob empfangene Bytes auf Seiten des Arduino überschrieben werden, könnte die verwendete Standard-Bibliothek um einen konditionalen Debug-Output erweitert werden.
Sollte dies die Problemquelle sein, könnte sie behoben werden, indem zum Beispiel ein größerer Buffer zum Zwischenspeichern der eintreffenden Bytes verwendet wird.
Sollte sich herausstellen, dass es auf Seiten des Arduinos keinen Fehler gibt, müsste stattdessen untersucht werden, was genau beim Aufruf der \enquote{WriteFile} Funktion passiert.
Da der Quellcode von Windows nicht frei verfügbar ist, würde dies einen hohen Aufwand mit sich bringen.

Wie bereits erwähnt, konnte diese Fehlersuche jedoch nicht vollzogen werden.
Nichtsdestotrotz konnte das Problem noch gelöst werden.
Experimentell wurde herausgefunden, dass der Fehler nicht auftritt, wenn höchstens 16 Byte auf einmal mit der \enquote{WriteFile} Funktion gesendet werden und ein paar Millisekunden gewartet wird, bevor die nächsten 16 Byte der Nachricht gesendet werden.
Diese Lösung funktioniert zwar, ist aber nicht unbedingt stailö
Da der Grund für den Fehler nicht bekannt ist, ist unklar warum diese Lösung genau funktioniert und unter welchen Umständen sie nicht mehr funktionieren würde.
Fortsetzungen dieserer Arbeit sollten deshalb die Fehlerquelle finden und sauberer lösen.


\section{Arduino-Programmierung} \label{umsetzungSW-MC}

Aufgrund der großen Unterschiede zwischen einem Desktop und einem \ac{MC}, war auch die Programmierung für die beiden Systeme relativ unterschiedlich.
Der größte, spürbare Unterschied ist wahrschenlich im stark begrenzten Speicherplatz zu finden.
Während der Arduino ausreichend Flash-Speicher besitzt, ist der dynamische RAM-Speicher mit 2KB stark begrenzt.
Mit der Verwendung der offiziellen Arduino IDE wird mitgeteilt, wie viel des dynamischen Speichers verwendet wird.
Dabei kann jedoch nicht berechnet werden, wie viel Speicherplatz während der Laufzeit durch lokale Variablen noch benötigt wird.
Es kann dadurch vorkommen, dass mehr Speicher benötigt wird als verfügbar ist.
In diesen Fällen wird bereits verwendeter Speicher überschrieben, was zu viel nicht erwünschten und nicht erwartbaren Verhalten führt.
Es ist mehrfach während der Entwicklung vorgekommen, dass unerklärliche Fehler aufgetreten sind, die mit einer verringerten Speichernutzung gefixt wurden.
Um einen besseren Überblick über die Anzahl wirklich verwendeten Speichers zu erhalten, wurden viele lokale Variablen zu globalen Variablen geändert.
Dadurch taucht deren Speicherplatz-Nutzung in der beim Kompilieren gezeigten Statistik verbleibenden Speichers mit auf.

Weiterhin ist die Programmierung des Arduinos durch das Ausbleiben eines Debuggers erschwert.
Während es durchaus Debugger für den Arduino gibt, benötigen diese ebenfalls eine gewisse Menge dynamischen Speichers.
Zum Finden von Problemen, die durch Speicherplatzmangel entstanden ist, sind die Debugger entsprechend ungeeignet.
Aber auch beim Finden anderer Bugs sind sie nicht weiter hilfreich, da sie selbst den Speicher zum Überlaufen bringen können.
Nichtsdestotrotz konnten Bugs über die Nutzung von Print-Statements gefunden und ausgemerzt werden.

Mit Ausnahme dieser teilweise schwer zu lösender Bugs, konnte das in Kapitel \ref{vorgehenSW-MC} beschriebene Konzept relativ leicht und nahezu 1-zu-1 in Code umgesetzt werden.

Es wurden hier auch mehrere Strategien für das Eliminieren von \lstinline|PlayedKey|s ausprobiert.
Hier hat sich herausgestellt, dass eine Eliminierung basierend auf der Spiellänge allein die besten Ergebnisse geliefert hat.
